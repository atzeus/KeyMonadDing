\documentclass{sigplanconf}
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{relsize}
\usepackage[a]{esvect}
\usepackage{marvosym}
\usepackage{graphicx}
\usepackage{url}
\usepackage{wasysym}
\usepackage{multirow}
\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}


\newcommand{\app}{\mathbin{<\!\!\!\!\mkern1.4mu\raisebox{-1.55pt}{\scalebox{0.9}{*}}\mkern1.4mu\!\!\!\!>}}
\newcommand{\aplus}{\mathbin{<\!\!\!\!\mkern1.4mu +\mkern1.4mu\!\!\!\!>}}
\newcommand{\fmap}{\mathbin{<\!\!\!\mkern-0.4mu\raisebox{0.0pt}{\scalebox{0.8}{\$}}\mkern-0.4mu\!\!\!>}}
\title{The Key Monad:\\Type-Safe Unconstrained Dynamic Typing}
\authorinfo{Atze van der Ploeg \and Koen Claessen}{Chalmers University of Technology, Sweden}
           {\{atze, koen\}@chalmers.se}
\authorinfo{Pablo Buiras}{Harvard University, United States}{pbuiras@seas.harvard.edu}
\begin{document}
\toappear{}
\maketitle
\newcommand{\api}{\textsc{api}}
\newcommand{\gadt}{\textsc{gadt}}
\newcommand{\ghc}{\textsc{ghc}}
\newcommand{\hoas}{\textsc{hoas}}
\newcommand{\st}{\textsc{st}}
\newcommand{\atze}[1]{{\it Atze says: #1}}
\newcommand{\koen}[1]{{\it Koen says: #1}}
\newcommand{\pablo}[1]{{\it Pablo says: #1}}


\begin{abstract}
 We present a small extension to Haskell called the
  Key monad. With the Key monad, unique keys of different types can be
  created and can be tested for equality. When two keys are equal, we
  also obtain a concrete proof that their types are equal. This gives us a form of
  dynamic typing, without the need for \ensuremath{\Conid{Typeable}} constraints. We
  show that our extension allows us to safely do things we could not
  otherwise do: it allows us to implement the \st{} monad (inefficiently), to implement an
  embedded form of arrow notation, and to translate
  parametric \hoas{} to typed de Bruijn indices, among others. Although strongly
  related to the \st{} monad, the Key monad is simpler and might be 
  easier to prove safe. We do not provide such a proof of the safety of the Key monad, but we note that, surprisingly, a full proof of the safety of
  the \st{} monad also remains elusive to this day. Hence, another reason for
  studying the Key monad is that a safety proof for it might
  be a stepping stone towards a safety proof of the \st{} monad.
\end{abstract}

\category{D.1.1}{Programming Techniques}{Applicative (Functional) Programming}
\category{D.3.3}{Programming Languages}{Language Constructs and Features}

\keywords
Functional programming, Haskell, Higher-order state, ST monad, Arrow notation, Parametric HOAS

\section{Introduction}

The \st{} monad \cite{stmonad} is an impressive feat of language design, but also a complicated beast. It provides and combines three separate features: (1) an abstraction for {\em global memory references} that can be efficiently written to and read from, (2) a mechanism for embedding computations involving these memory references in {\em pure computations}, and (3) a design that allows references in the same computation to be of {\em arbitrary, different types}, in a type-safe manner.

\begin{figure}[t]
\rule{\columnwidth}{0.4pt}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{KeyM}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Key}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Monad}\;(\Conid{KeyM}\;\Varid{s}){}\<[E]%
\\
\>[B]{}\Varid{newKey}{}\<[15]%
\>[15]{}\mathbin{::}\Conid{KeyM}\;\Varid{s}\;(\Conid{Key}\;\Varid{s}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Varid{testEquality}{}\<[15]%
\>[15]{}\mathbin{::}\Conid{Key}\;\Varid{s}\;\Varid{a}\to \Conid{Key}\;\Varid{s}\;\Varid{b}\to \Conid{Maybe}\;(\Varid{a}:\sim:\Varid{b}){}\<[E]%
\\
\>[B]{}\Varid{runKeyM}{}\<[15]%
\>[15]{}\mathbin{::}(\forall\;\Varid{s}.\:\Conid{KeyM}\;\Varid{s}\;\Varid{a})\to \Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{data}\;\Varid{a}:\sim:\Varid{b}\;\mathbf{where}\;\Conid{Refl}\mathbin{::}\Varid{a}:\sim:\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{The Key monad interface}
\label{fig:key-monad}
\end{figure}

In this paper, we provide a new abstraction in Haskell (+ \gadt s and rank-2 types) that
embodies only feature (3) above: the combination of references (which we call {\em keys}) of different, unconstrained types in the same computation. In the \st{} monad, the essential invariant that must hold for feature (3), is that when two references are the same, then their types \emph{must also be the same}. Our new abstraction splits reasoning based on this invariant into a separate interface, and makes it available to the user. The result is a small library called {\em the Key monad}, of which the \api{} is given in Figure\ \ref{fig:key-monad}. 

The Key monad \ensuremath{\Conid{KeyM}} is basically a crippled version of the \st{} monad: we can monadically create keys of type \ensuremath{\Conid{Key}\;\Varid{s}\;\Varid{a}} using the function \ensuremath{\Varid{newKey}}, but we cannot read or write values to these keys; in fact, keys do not carry any values at all. We can convert a computation in \ensuremath{\Conid{KeyM}} into a pure value by means of \ensuremath{\Varid{runKeyM}}, which requires the argument computation to be polymorphic in \ensuremath{\Varid{s}}, just like \ensuremath{\Varid{runST}} would.


The only new feature is the function \ensuremath{\Varid{testEquality}}, which compares two keys for equality. But the keys do not have to be of the same type! They just have to come from the same \ensuremath{\Conid{KeyM}} computation, indicated by the \ensuremath{\Varid{s}} argument. If two keys are not equal, the answer is \ensuremath{\Conid{Nothing}}. However, if two keys are found to be equal, {\em then their types must also be the same}, and the answer is \ensuremath{\Conid{Just}\;\Conid{Refl}}, where \ensuremath{\Conid{Refl}} is a constructor from the \gadt{} \ensuremath{\Varid{a}:\sim:\Varid{b}} that functions as the ``proof'' that \ensuremath{\Varid{a}} and \ensuremath{\Varid{b}} are in fact the same type\footnote{It is actually possible to add \ensuremath{\Varid{testEquality}} to the standard interface of \ensuremath{\Conid{STRef}}s, which would provide much the same features in the \st{} monad as the Key monad would, apart from some laziness issues. However, because of its simplicity, we think the Key monad is interesting in its own right.}. This gives us a form of dynamic typing, \emph{without} the need for \ensuremath{\Conid{Typeable}} constraints.



Why is the Key monad interesting? There are three separate reasons.

First, the Key monad embodies the insight that when two Keys are the same then their types must be the same, and makes reasoning based on this available to the user via \ensuremath{\Varid{testEquality}}. This makes the Key monad applicable in situations where the \st{} monad would not have been suitable. In fact, the bulk of this paper presents examples of uses of the Key monad that would have been impossible without \ensuremath{\Varid{testEquality}}.

Second, the Key monad is simpler than the \st{} monad, because it does not involve global references, or any updatable state at all. We would like to argue that therefore, the Key monad is easier to understand than the \st{} monad. Moreover, given the Key monad, the \st{} monad is actually implementable in plain Haskell, albeit in a less time- and memory-efficient way than the original \st{} monad (that is, missing feature (1) above, but still providing features (2) and (3)).

This second reason comes with a possibly unexpected twist.

After its introduction in 1994, several papers have claimed to establish the safety, fully or partially, of the \st{} monad in Haskell \cite{stmonad,LaunchburySabry,AriolaSabry,MoggiSabry}. By safety we mean three things: (a) type safety (programs using the \st{} monad are still type safe), (b) referential transparency (programs using the \st{} monad are still referentially transparent), and (c) abstraction safety (programs using the \st{} monad still obey the parametricity theorem). It came as a complete surprise to the authors that {\em none of the papers we came across in our literature study actually establishes the safety of the \st{} monad in Haskell!}

So, there is a third reason for studying the Key monad: A safety proof for the Key monad could be simpler than a safety proof for the \st{} monad. The existence of such a proof would conceivably lead to a safety proof of the \st{} monad as well; in fact this is the route that we would currently recommend for anyone trying to prove the \st{} monad safe.

This paper does not provide a formal safety proof of the Key monad. Instead, we will argue that the safety of the Key monad is just as plausible as the safety of the \st{} monad. We hope that the reader will not hold it against us that we do not provide a safety proof. Instead, we would like this paper to double as a call to arms, to find (ideally, mechanized) proofs of safety of both the Key monad and the \st{} monad!

Our contributions are as follows:
\begin{itemize}
\item We present the Key monad (Section \ref{keym}), its implementation (Section \ref{impl}), and informally argue for its safety (Section \ref{safety}).
\item We show that the added power of the Key monad allows us to do things we cannot do without it, namely it allows us
     \begin{itemize}
          \item to implement the \st{} monad (Section \ref{keym});
          \item to implement an \emph{embedded} form of arrow notation (Section \ref{arrow});
          \item to represent typed variables in typed representations of syntax (Section \ref{syntax});
          \item to translate parametric \hoas{} to nested de Bruijn indices, which allows interpretations of parametric \hoas{} terms, such as translation to Cartesian closed categories, which are not possible otherwise (Section \ref{syntax}).
\end{itemize}
\item We identify some key missing pieces in the correctness proof of the \st{} monad (Section \ref{stdis}). The Key monad may be a stepping stone to finding the complete proof.
\end{itemize}

\noindent The Haskell code discussed in this paper can be found online at: 
\url{https://github.com/koengit/KeyMonad}

\section{The Key Monad}
\label{keym}

In this section, we describe the Key monad, what it gives us, and its relation to the \st{} monad.

The interface of the Key monad (Figure\ \ref{fig:key-monad}) features two abstract types (i.e., types with no user-accessible constructors): \ensuremath{\Conid{Key}} and \ensuremath{\Conid{KeyM}}. The Key monad gives the user the power to create a new, unique value of type \ensuremath{\Conid{Key}\;\Varid{s}\;\Varid{a}} via \ensuremath{\Varid{newKey}}. The only operation that is supported on the type \ensuremath{\Conid{Key}} is \ensuremath{\Varid{testEquality}}, which checks if two given keys are the same, and if they are returns a ``proof'' that the types associated with the names are the same types. 

\subsection{Unconstrained Dynamic Typing}

The power to prove that two types are the same allows us to do similar things as with \ensuremath{\Conid{\Conid{Data}.Typeable}}, but \emph{without} the need for \ensuremath{\Conid{Typeable}} constraints. For instance, we can create a variant of \ensuremath{\Conid{Dynamic}} using \ensuremath{\Conid{Key}}s instead of type representations. When given a key and value, we can ``lock up'' the value in a box, which, like \ensuremath{\Conid{Dynamic}}, hides the type of its contents.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Box}\;\Varid{s}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Lock}\mathbin{::}\Conid{Key}\;\Varid{s}\;\Varid{a}\to \Varid{a}\to \Conid{Box}\;\Varid{s}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 If we have a \ensuremath{\Conid{Key}} and a \ensuremath{\Conid{Box}}, we can try to unlock the box to recover the value it contains.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{unlock}\mathbin{::}\Conid{Key}\;\Varid{s}\;\Varid{a}\to \Conid{Box}\;\Varid{s}\to \Conid{Maybe}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{unlock}\;\Varid{k}\;(\Conid{Lock}\;\Varid{k'}\;\Varid{x})\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mathbf{case}\;\Varid{testEquality}\;\Varid{k}\;\Varid{k'}\;\mathbf{of}{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\Conid{Just}\;\Conid{Refl}{}\<[16]%
\>[16]{}\to \Conid{Just}\;\Varid{x}{}\<[E]%
\\
\>[4]{}\hsindent{1}{}\<[5]%
\>[5]{}\Conid{Nothing}{}\<[16]%
\>[16]{}\to \Conid{Nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
If we used the right key, we get \ensuremath{\Conid{Just}} the value in the box, and we get \ensuremath{\Conid{Nothing}} otherwise.

Note that the only way to unlock a \ensuremath{\Conid{Box}} successfully involves using the \ensuremath{\Conid{Key}} that was used to create it, not merely a \ensuremath{\Conid{Key}} with the right type. The function \ensuremath{\Varid{testEquality}} only returns \ensuremath{\Conid{Just}\;\Conid{Refl}} when the keys are identical, not when the types are the same. Thus, the Key monad does not provide a means of checking type equality at run-time.

\subsection{Heterogeneous Maps}

We can use \ensuremath{\Conid{Box}}es to create a kind of \emph{heterogeneous maps}: a data structure that that maps keys to values of the type corresponding to the key. The interesting feature here is that the type of these heterogenous maps does not depend on the types of the values that are stored in it, nor do the functions have \ensuremath{\Conid{Typeable}} constraints. We can implement such maps straightforwardly as follows\footnote{For simplicity, this is a rather inefficient implementation, but a more efficient implementation (using \ensuremath{\Conid{IntMap}}s) can be given if we add a function \ensuremath{\Varid{hashKey}\mathbin{::}\Conid{Key}\;\Varid{s}\;\Varid{a}\to \Conid{Int}} to the Key monad.}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{newtype}\;\Conid{KeyMap}\;\Varid{s}\mathrel{=}\Conid{KM}\;[\mskip1.5mu \Conid{Box}\;\Varid{s}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{empty}\mathbin{::}\Conid{KeyMap}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\Varid{empty}\mathrel{=}\Conid{KM}\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{insert}\mathbin{::}\Conid{Key}\;\Varid{s}\;\Varid{a}\to \Varid{a}\to \Conid{KeyMap}\;\Varid{s}\to \Conid{KeyMap}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\Varid{insert}\;\Varid{k}\;\Varid{v}\;(\Conid{KM}\;\Varid{l})\mathrel{=}\Conid{KM}\;(\Conid{Lock}\;\Varid{k}\;\Varid{v}\mathbin{:}\Varid{l}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{lookup}\mathbin{::}\Conid{Key}\;\Varid{s}\;\Varid{a}\to \Conid{KeyMap}\;\Varid{s}\to \Conid{Maybe}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{lookup}\;\Varid{k}\;(\Conid{KM}\;[\mskip1.5mu \mskip1.5mu]){}\<[24]%
\>[24]{}\mathrel{=}\Conid{Nothing}{}\<[E]%
\\
\>[B]{}\Varid{lookup}\;\Varid{k}\;(\Conid{KM}\;(\Varid{h}\mathbin{:}\Varid{t})){}\<[24]%
\>[24]{}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{unlock}\;\Varid{k}\;\Varid{h}\mathbin{`\Varid{mplus}`}\Varid{lookup}\;\Varid{k}\;(\Conid{KM}\;\Varid{t}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}(\mathbin{!})\mathbin{::}\Conid{KeyMap}\;\Varid{s}\to \Conid{Key}\;\Varid{s}\;\Varid{a}\to \Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{m}\mathbin{!}\Varid{k}\mathrel{=}\Varid{fromJust}\;(\Varid{lookup}\;\Varid{k}\;\Varid{m}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Implementing the \st{} Monad}

Armed with our newly obtained \ensuremath{\Conid{KeyMap}}s, we can implement an (inefficient) version of the \st{} monad as follows. The implementation of \ensuremath{\Conid{STRef}}s is simply as an alias for \ensuremath{\Conid{Key}}s:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{STRef}\;\Varid{s}\;\Varid{a}\mathrel{=}\Conid{Key}\;\Varid{s}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We can now use the Key monad to create new keys, and use a \ensuremath{\Conid{KeyMap}} to represent the current state of all created \ensuremath{\Conid{STRef}}s.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{newtype}\;\Conid{ST}\;\Varid{s}\;\Varid{a}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{6}{}\<[6]%
\>[6]{}\Conid{ST}\;(\Conid{StateT}\;(\Conid{KeyMap}\;\Varid{s})\;(\Conid{KeyM}\;\Varid{s})\;\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{deriving}\;(\Conid{Functor},\Conid{Applicative},\Conid{Monad}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
It is now straightforward to implement the operations for \ensuremath{\Conid{STRef}}s:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{newSTRef}\mathbin{::}\Varid{a}\to \Conid{ST}\;\Varid{s}\;(\Conid{STRef}\;\Varid{s}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Varid{newSTRef}\;\Varid{v}\mathrel{=}\Conid{ST}\mathbin{\$}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{do}\;{}\<[7]%
\>[7]{}\Varid{k}\leftarrow \Varid{lift}\;\Varid{newKey}{}\<[E]%
\\
\>[7]{}\Varid{modify}\;(\Varid{insert}\;\Varid{k}\;\Varid{v}){}\<[E]%
\\
\>[7]{}\Varid{return}\;\Varid{k}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{readSTRef}\mathbin{::}\Conid{STRef}\;\Varid{s}\;\Varid{a}\to \Conid{ST}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{readSTRef}\;\Varid{r}\mathrel{=}\Conid{ST}\mathbin{\$}(!\:r)\fmap\Varid{get}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{writeSTRef}\mathbin{::}\Conid{STRef}\;\Varid{s}\;\Varid{a}\to \Varid{a}\to \Conid{ST}\;\Varid{s}\;(){}\<[E]%
\\
\>[B]{}\Varid{writeSTRef}\;\Varid{k}\;\Varid{v}\mathrel{=}\Conid{ST}\mathbin{\$}\Varid{modify}\;(\Varid{insert}\;\Varid{k}\;\Varid{v}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Finally, the implementation of \ensuremath{\Varid{runST}} simply runs the monadic computation contained in the \st{} type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{runST}\mathbin{::}(\forall\;\Varid{s}.\:\Conid{ST}\;\Varid{s}\;\Varid{a})\to \Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{runST}\;\Varid{m}\mathrel{=}\Varid{runKeyM}\mathbin{\$}\mathbf{case}\;\Varid{m}\;\mathbf{of}{}\<[E]%
\\
\>[B]{}\hsindent{12}{}\<[12]%
\>[12]{}\Conid{ST}\;\Varid{n}\to \Varid{evalStateT}\;\Varid{n}\;\Varid{empty}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Relation with the \st{} Monad}

While the Key monad can be used to implement the \st{} monad, the converse is not true. The problem is that there is no function:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{testEquality}\mathbin{::}{}\<[18]%
\>[18]{}\Conid{STRef}\;\Varid{s}\;\Varid{a}\to \Conid{STRef}\;\Varid{s}\;\Varid{b}\to {}\<[E]%
\\
\>[18]{}\Conid{Maybe}\;(\Varid{a}:\sim:\Varid{b}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
It is straightforward to implement this function using \ensuremath{\Varid{unsafeCoerce}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{testEquality}\;\Varid{x}\;\Varid{y}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid \Varid{x}\equiv \Varid{unsafeCoerce}\;\Varid{y}{}\<[27]%
\>[27]{}\mathrel{=}\Conid{Just}\;(\Varid{unsafeCoerce}\;\Conid{Refl}){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid \Varid{otherwise}{}\<[27]%
\>[27]{}\mathrel{=}\Conid{Nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The \ensuremath{\Varid{unsafeCoerce}} in \ensuremath{\Varid{x}\equiv \Varid{unsafeCoerce}\;\Varid{y}} is needed because the types of the references might not be the same. Hence, another way to think of this paper is that we claim that the above function is \emph{safe}, that this allows us to do things which we could not do before, and that we propose this as an extension of the \st{} monad library. 

With the above \ensuremath{\Varid{testEquality}} function for \ensuremath{\Conid{STRef}}s it is possible to implement something similar to the Key monad, but the Key monad is more lazy. In particular, for the Key monad, the following holds: 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\bot \sequ \Varid{m}\;\equiv \;\Varid{m}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
This does not hold even for the lazy \st{} monad, which will give \ensuremath{\bot } on for example \ensuremath{\bot \sequ \Varid{newSTRef}\;\mathrm{0}}.

The extra laziness of the Key monad allows us to create an infinite list of \ensuremath{\Conid{Key}}s for example:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{newKeys}\mathbin{::}\Conid{KeyM}\;\Varid{s}\;[\mskip1.5mu \Conid{Key}\;\Varid{s}\;\Varid{a}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{newKeys}\mathrel{=}\Varid{liftM2}\;(\mathbin{:})\;\Varid{newKey}\;\Varid{newKeys}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
This is something you can only do using \ensuremath{\Varid{unsafeInterleaveST}} in the \st{} monad.

Why is the \ensuremath{\Varid{testEquality}} function for \ensuremath{\Conid{STRef}}s safe? The reason is that if two references are the same, then their types must also be the same. This invariant must already be true for \st{} references, because otherwise we could have two references pointing to the same location with different types. Writing to one reference and then reading from the other would coerce the value from one type to another! Hence, the Key monad  splits reasoning based on this invariant into a separate interface and makes it available to the user via \ensuremath{\Varid{testEquality}}.

Following the same line of reasoning, it is already possible to implement a similar, but weaker, version of \ensuremath{\Varid{testEquality}} using only the standard \st{} monad functions. If we represent keys of type \ensuremath{\Conid{Key}\;\Varid{s}\;\Varid{a}} as a pair of an identifier and an \ensuremath{\Conid{STRef}} containing values of type \ensuremath{\Varid{a}}, then we can create a function that casts a value of type \ensuremath{\Varid{a}} to \ensuremath{\Varid{b}}, albeit monadically, i.e. we get a monadic cast function \ensuremath{\Varid{a}\to \Conid{ST}\;\Varid{s}\;\Varid{b}} instead of a proof \ensuremath{\Varid{a}:\sim:\Varid{b}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}c<{\hspost}@{}}%
\column{3E}{@{}l@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Key}\;\Varid{s}\;\Varid{a}\mathrel{=}\Conid{Key}\;\{\mskip1.5mu {}\<[22]%
\>[22]{}\Varid{ident}\mathbin{::}\Conid{STRef}\;\Varid{s}\;(),{}\<[E]%
\\
\>[22]{}\Varid{ref}{}\<[28]%
\>[28]{}\mathbin{::}\Conid{STRef}\;\Varid{s}\;\Varid{a}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{newKey}\mathbin{::}\Conid{ST}\;\Varid{s}\;(\Conid{Key}\;\Varid{s}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Varid{newKey}\mathrel{=}\Conid{Key}\fmap\Varid{newSTRef}\;()\app\Varid{newSTRef}\;\bot {}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{testEqualityM}\mathbin{::}{}\<[19]%
\>[19]{}\Conid{Key}\;\Varid{s}\;\Varid{a}\to \Conid{Key}\;\Varid{s}\;\Varid{b}\to {}\<[E]%
\\
\>[19]{}\Conid{Maybe}\;(\Varid{a}\to \Conid{ST}\;\Varid{s}\;\Varid{b}){}\<[E]%
\\
\>[B]{}\Varid{testEqualityM}\;\Varid{ka}\;\Varid{kb}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid {}\<[3E]%
\>[6]{}\Varid{ident}\;\Varid{ka}\not\equiv \Varid{ident}\;\Varid{kb}{}\<[28]%
\>[28]{}\mathrel{=}\Conid{Nothing}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid {}\<[3E]%
\>[6]{}\Varid{otherwise}{}\<[28]%
\>[28]{}\mathrel{=}\Conid{Just}\mathbin{\$}\lambda \Varid{x}\to {}\<[E]%
\\
\>[6]{}\hsindent{2}{}\<[8]%
\>[8]{}\mathbf{do}\;{}\<[12]%
\>[12]{}\Varid{writeSTRef}\;(\Varid{ref}\;\Varid{ka})\;\Varid{x}{}\<[E]%
\\
\>[12]{}\Varid{readSTRef}\;(\Varid{ref}\;\Varid{kb}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
This implementation, although a bit brittle because it relies on strong invariants, makes use of the insight that if the two references are actually the same reference, then writing to one reference must trigger a result in the other.




\subsection{Relation to \ensuremath{\Conid{Typeable}}}

The {\tt base} library \ensuremath{\Conid{\Conid{Data}.Typeable}} provides similar functionality to the Key monad. Typeable is a type class that provides a value-level representation of the types that implement it. The \ensuremath{\Conid{Typeable}} library provides a function
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{eqT}\mathbin{::}\forall\;\Varid{a}\;\Varid{b}.\:(\Conid{Typeable}\;\Varid{a},\Conid{Typeable}\;\Varid{b})\Rightarrow \Conid{Maybe}\;(\Varid{a}:\sim:\Varid{b}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{(:\sim:)} is the \gadt{} from Figure \ref{fig:key-monad}. This function gives \ensuremath{\Conid{Just}\;\Conid{Refl}} if both \emph{types} are the same, whereas \ensuremath{\Varid{testEquality}} from the Key monad only gives \ensuremath{\Conid{Just}\;\Conid{Refl}} if the \emph{keys} are the same. If we have two keys with the same type, but which originate from different \ensuremath{\Varid{newKey}} invocations, the result of \ensuremath{\Varid{testEquality}} will be \ensuremath{\Conid{Nothing}}. 

Another difference is that with the Key monad, to obtain a key for a type \ensuremath{\Varid{a}}, we do not need a constraint on the type \ensuremath{\Varid{a}}, which we do need to get a value-level type representation using \ensuremath{\Conid{Typeable}}. These constraints can leak to the user-level interface. For example, we can also implement a variant of the \st{} monad using \ensuremath{\Conid{Typeable}}, by storing in each \ensuremath{\Conid{STRef}} a unique number and a representation of its type. We will then need to change the interface such that we have access to the value-level type representations, by adding \ensuremath{\Conid{Typeable}} constraints. For example, the type of \ensuremath{\Varid{newSTRef}} then becomes
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{newSTRef}\mathbin{::}\Conid{Typeable}\;\Varid{a}\Rightarrow \Varid{a}\to \Conid{ST}\;\Varid{s}\;(\Conid{STRef}\;\Varid{s}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In fact, all example usages of the Key monad in this paper can also be implemented by using \ensuremath{\Conid{Typeable}} and unique numbers and adding constraints to the user interface. We could even implement the Key monad itself by adding a \ensuremath{\Conid{Typeable}} constraint to \ensuremath{\Varid{newKey}}. However, using the Key monad has the benefit that it is \emph{unconstrained}: we can use it even when \ensuremath{\Conid{Typeable}} dictionaries are unavailable.

\subsection{Key Monad Laws}
\label{seclaws}
Informally, the Key monad allows us to create new keys and compare them, maybe obtaining a proof of the equality of their associated types. To give a more precise specification and to allow equational reasoning, we also present the Key monad laws shown in Figure~\ref{laws}, which we will now briefly discuss. 

\begin{figure}
\hspace{-0.7cm}
\begin{tabular}{ r  c  l r}
\begin{minipage}{0.4\columnwidth}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{do}\;{}\<[5]%
\>[5]{}\Varid{k}\leftarrow \Varid{newKey}{}\<[E]%
\\
\>[5]{}\Varid{f}\;(\Varid{testEquality}\;\Varid{k}\;\Varid{k}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}& \ensuremath{\mathrel{=}} & \hspace{-0.5cm}\begin{minipage}{0.3\columnwidth}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{do}\;{}\<[5]%
\>[5]{}\Varid{k}\leftarrow \Varid{newKey}{}\<[E]%
\\
\>[5]{}\Varid{f}\;(\Conid{Just}\;\Conid{Refl}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}& (\ensuremath{\Varid{sameKey}}) \\[-0.2cm]
\begin{minipage}{0.4\columnwidth}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{do}\;{}\<[5]%
\>[5]{}\Varid{k}\leftarrow \Varid{newKey}{}\<[E]%
\\
\>[5]{}\Varid{l}\leftarrow \Varid{newKey}{}\<[E]%
\\
\>[5]{}\Varid{f}\;(\Varid{testEquality}\;\Varid{k}\;\Varid{l}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}&  \ensuremath{\mathrel{=}} & \hspace{-0.5cm}\begin{minipage}{0.3\columnwidth}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{do}\;{}\<[5]%
\>[5]{}\Varid{k}\leftarrow \Varid{newKey}{}\<[E]%
\\
\>[5]{}\Varid{l}\leftarrow \Varid{newKey}{}\<[E]%
\\
\>[5]{}\Varid{f}\;\Conid{Nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}& (\ensuremath{\Varid{distinctKey}}) \\[-0.2cm] \begin{minipage}{0.22\columnwidth}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{do}\;{}\<[5]%
\>[5]{}\Varid{x}\leftarrow \Varid{f}{}\<[E]%
\\
\>[5]{}\Varid{y}\leftarrow \Varid{g}{}\<[E]%
\\
\>[5]{}\Varid{h}\;\Varid{x}\;\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}
 &  \ensuremath{\mathrel{=}} & \hspace{-0.5cm}\begin{minipage}{0.2\columnwidth}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{do}\;{}\<[5]%
\>[5]{}\Varid{y}\leftarrow \Varid{g}{}\<[E]%
\\
\>[5]{}\Varid{x}\leftarrow \Varid{f}{}\<[E]%
\\
\>[5]{}\Varid{h}\;\Varid{x}\;\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}
& (\ensuremath{\Varid{commutative}}) \\[-0.2cm]
\begin{minipage}{0.15\columnwidth} \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{m}\sequ \Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage} & \ensuremath{\mathrel{=}} & \hspace{-0.5cm}\begin{minipage}{0.1\columnwidth} \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 \end{minipage} & (\ensuremath{\Varid{purity}})  \\[-0.2cm]
\begin{minipage}{0.35\columnwidth} \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{runKey}\;(\Varid{return}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage}& \ensuremath{\mathrel{=}} &\hspace{-0.55cm} \begin{minipage}{0.1\columnwidth} \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 \end{minipage} & (\ensuremath{\Varid{runReturn}}) \\[-0.2cm]
\begin{minipage}{0.35\columnwidth} \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{runKey}\;(\Varid{f}\fmap\Varid{m}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 \end{minipage}  & \ensuremath{\mathrel{=}} & \hspace{-0.5cm}\begin{minipage}{0.3\columnwidth} \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{f}\;(\Varid{runKey}\;\Varid{m}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{minipage} & (\ensuremath{\Varid{runF}}) \\[-0.15cm]
\multicolumn{3}{c}{(if \ensuremath{\Varid{m}\mathbin{::}\forall\;\Varid{s}.\:\Conid{KeyM}\;\Varid{s}\;\Varid{a}})} & 
\end{tabular}
\caption{Key monad laws}
\label{laws}
\end{figure}

The \ensuremath{\Varid{sameKey}} and \ensuremath{\Varid{distinctKey}} laws describe the behavior of \ensuremath{\Varid{testEquality}}.
The \ensuremath{\Varid{commutative}} law states that the Key monad is a commutative monad: the order of actions does not matter. The \ensuremath{\Varid{purity}} law might be a bit surprising: it states that doing some Key computation and then throwing away the result is the same as not doing anything at all! The reason for this is that the only property of each key is that it is distinct from all other keys: making keys and then throwing them away has no (observable) effect on the rest of the computation.

The last two laws, \ensuremath{\Varid{runReturn}} and \ensuremath{\Varid{runF}},  state how we can get the values out of a \ensuremath{\Conid{KeyM}} computation with \ensuremath{\Varid{runKey}}. The \ensuremath{\Varid{runF}} law states that we can lazily get the results of a (potentially) infinite \ensuremath{\Conid{KeyM}} computation. The side condition that \ensuremath{\Varid{m}} has type \ensuremath{\forall\;\Varid{s}.\:\Conid{KeyM}\;\Varid{s}\;\Varid{a}} (for some type \ensuremath{\Varid{a}}) rules out wrong specialization of the law, such as:  
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{runKey}\;(\Varid{f}\fmap\Varid{newKey})\mathrel{=}\Varid{f}\;(\Varid{runKey}\;\Varid{newKey}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
This specialization does \emph{not} hold because, the left hand side type-checks, but the right hand side does not: the ``s'' would escape. 



\section{Embedding Arrow Notation}
\label{arrow}
\begin{figure}
  \rule{\columnwidth}{0.4pt}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{class}\;\Conid{Arrow}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{arr}{}\<[10]%
\>[10]{}\mathbin{::}(\Varid{x}\to \Varid{y})\to \Varid{a}\;\Varid{x}\;\Varid{y}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\mathbin{>\!\!\!>\!\!\!>}){}\<[10]%
\>[10]{}\mathbin{::}\Varid{a}\;\Varid{x}\;\Varid{y}\to \Varid{a}\;\Varid{y}\;\Varid{z}\to \Varid{a}\;\Varid{x}\;\Varid{z}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{first}{}\<[10]%
\>[10]{}\mathbin{::}\Varid{a}\;\Varid{x}\;\Varid{y}\to \Varid{a}\;(\Varid{x},\Varid{z})\;(\Varid{y},\Varid{z}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{second}\mathbin{::}\Varid{a}\;\Varid{x}\;\Varid{y}\to \Varid{a}\;(\Varid{z},\Varid{x})\;(\Varid{z},\Varid{y}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{second}\;\Varid{x}\mathrel{=}\Varid{flip}\mathbin{>\!\!\!>\!\!\!>}\Varid{first}\;\Varid{x}\mathbin{>\!\!\!>\!\!\!>}\Varid{flip}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{flip}{}\<[17]%
\>[17]{}\mathrel{=}\Varid{arr}\;(\lambda (\Varid{x},\Varid{y})\to (\Varid{y},\Varid{x})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{The  arrow type class.}
\label{arrowsdef}
\end{figure}

In this section, we show that the Key monad gives us the power to implement an \emph{embedded} form of \emph{arrow syntax}. Without the Key monad, such syntax is, as far as we know, only possible by using specialized compiler support.

\subsection{Arrows vs Monads}

The \ensuremath{\Conid{Arrow}} type class, shown in Figure\ \ref{arrowsdef}, was introduced by Hughes \cite{arrows} as an interface that is like monads, but which allows for more static information about the constructed computations to be extracted. However, in contrast to monads, arrows do not directly allow intermediate values to be \emph{named}; instead, expressions must be written in \emph{point-free style}. 

As an example, an arrow computation which feeds the same input to two arrows, and adds their outputs, can be expressed in point-free style as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{addA}\mathbin{::}\Conid{Arrow}\;\Varid{a}\Rightarrow \Varid{a}\;\Varid{x}\;\Conid{Int}\to \Varid{a}\;\Varid{x}\;\Conid{Int}\to \Varid{a}\;\Varid{x}\;\Conid{Int}{}\<[E]%
\\
\>[B]{}\Varid{addA}\;\Varid{f}\;\Varid{g}\mathrel{=}{}\<[13]%
\>[13]{}\Varid{arr}\;(\lambda \Varid{x}\to (\Varid{x},\Varid{x})){}\<[32]%
\>[32]{}\mathbin{>\!\!\!>\!\!\!>}\Varid{first}\;\Varid{f}\mathbin{>\!\!\!>\!\!\!>}{}\<[E]%
\\
\>[13]{}\Varid{second}\;\Varid{g}{}\<[32]%
\>[32]{}\mathbin{>\!\!\!>\!\!\!>}\Varid{arr}\;(\lambda (\Varid{x},\Varid{y})\to \Varid{x}\mathbin{+}\Varid{y}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
With monads, a similar computation can be written more clearly by naming intermediate values:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{addM}\mathbin{::}\Conid{Monad}\;\Varid{m}\Rightarrow {}\<[21]%
\>[21]{}(\Varid{x}\to \Varid{m}\;\Conid{Int})\to (\Varid{x}\to \Varid{m}\;\Conid{Int})\to {}\<[E]%
\\
\>[21]{}(\Varid{x}\to \Varid{m}\;\Conid{Int}){}\<[E]%
\\
\>[B]{}\Varid{addM}\;\Varid{f}\;\Varid{g}\mathrel{=}\lambda \Varid{z}\to {}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{do}\;{}\<[9]%
\>[9]{}\Varid{x}\leftarrow \Varid{f}\;\Varid{z}{}\<[E]%
\\
\>[9]{}\Varid{y}\leftarrow \Varid{g}\;\Varid{z}{}\<[E]%
\\
\>[9]{}\Varid{return}\;(\Varid{x}\mathbin{+}\Varid{y}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
To overcome this downside of arrows, Paterson introduced arrow notation~\cite{arrownot}. In this notation, the above arrow computation can be written as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{addA}\mathbin{::}\Conid{Arrow}\;\Varid{a}\Rightarrow \Varid{a}\;\Varid{b}\;\Conid{Int}\to \Varid{a}\;\Varid{b}\;\Conid{Int}\to \Varid{a}\;\Varid{b}\;\Conid{Int}{}\<[E]%
\\
\>[B]{}\Varid{addA}\;\Varid{f}\;\Varid{g}\mathrel{=}\mathbf{proc}\;\Varid{z}\to \mathbf{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{x}\leftarrow \Varid{f}\prec\Varid{z}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{y}\leftarrow \Varid{g}\prec\Varid{z}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{returnA}\prec\Varid{x}\mathbin{+}\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Specialized compiler support is offered by \ghc{}, which desugars this notation into point free expressions. 

With the Key monad, we can name intermediate values in arrow
computations using \emph{regular} monadic do notation, without relying
on specialized compiler support. The \ensuremath{\Varid{addA}} computation above can be expressed using our \emph{embedded} arrow notation as follows: 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{addA}\mathbin{::}\Conid{Arrow}\;\Varid{a}\Rightarrow \Varid{a}\;\Varid{b}\;\Conid{Int}\to \Varid{a}\;\Varid{b}\;\Conid{Int}\to \Varid{a}\;\Varid{b}\;\Conid{Int}{}\<[E]%
\\
\>[B]{}\Varid{addA}\;\Varid{f}\;\Varid{g}\mathrel{=}\Varid{proc}\mathbin{\$}\lambda \Varid{z}\to \mathbf{do}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{x}\leftarrow \Varid{f}\prec\Varid{z}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{y}\leftarrow \Varid{g}\prec\Varid{z}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{return}\mathbin{\$}(\mathbin{+})\fmap\Varid{x}\app\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We use a function conveniently called \ensuremath{\Varid{proc}} and use an infix function conveniently called \ensuremath{(\prec)}. Slightly less nice is that we now have to use the \ensuremath{\Conid{Applicative}} interface to combine values resulting from arrow computations: we have to write \ensuremath{(\mathbin{+})\fmap\Varid{x}\app\Varid{y}} instead of \ensuremath{\Varid{x}\mathbin{+}\Varid{y}}. Note that \ensuremath{\Varid{proc}} is a \emph{function}, which does all the plumbing to rewrite the syntax to a point-free expression, which is normally done in a compiler pass.

The difference between \ensuremath{\mathbf{do}} notation and arrow notation is that in arrow notation, one cannot observe intermediate values to decide what to do next. For example, we \emph{cannot} do the following:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{ifArrow}\mathbin{::}{}\<[13]%
\>[13]{}\Varid{a}\;\Conid{Int}\;\Varid{x}\to \Varid{a}\;\Conid{Int}\;\Varid{x}\to \Varid{a}\;\Conid{Int}\;\Varid{x}{}\<[E]%
\\
\>[B]{}\Varid{ifArrow}\;\Varid{t}\;\Varid{f}\mathrel{=}\mathbf{proc}\;\Varid{z}\to \mathbf{do}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mathbf{case}\;\Varid{z}\;\mathbf{of}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\mathrm{0}\to \Varid{t}\prec\Varid{z}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}\anonymous \to \Varid{f}\prec\Varid{z}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Allowing this kind of behavior would make it impossible to translate arrow notation to arrow expressions, because this is exactly the power that monads have but that arrows lack \cite{idiomarrmonad}. To mimic this restriction in our embedded arrow notation, our function \ensuremath{(\prec)} has the following type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\prec)\mathbin{::}\Conid{Arrow}\;\Varid{a}\Rightarrow \Varid{a}\;\Varid{x}\;\Varid{y}\to \Conid{Cage}\;\Varid{s}\;\Varid{x}\to {}\<[E]%
\\
\>[B]{}\hsindent{15}{}\<[15]%
\>[15]{}\Conid{ArrowSyntax}\;\Varid{a}\;\Varid{s}\;(\Conid{Cage}\;\Varid{s}\;\Varid{y}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The type \ensuremath{\Conid{ArrowSyntax}} is the monad which we use to define our embedded
arrow notation. The input and output of the arrow computations are
enclosed in \ensuremath{\Conid{Cage}}s, a type which disallows observation of the value of type \ensuremath{\Varid{x}} it ``contains''. 

\subsection{Implementing Embedded Arrow Syntax}

The implementation of a \ensuremath{\Conid{Cage}} is as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{newtype}\;\Conid{Cage}\;\Varid{s}\;\Varid{x}\mathrel{=}\Conid{Cage}\;\{\mskip1.5mu \Varid{open}\mathbin{::}\Conid{KeyMap}\;\Varid{s}\to \Varid{x}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{deriving}\;(\Conid{Functor},\Conid{Applicative}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Informally, a \ensuremath{\Conid{Cage}} ``contains'' a value of type \ensuremath{\Varid{x}}, but in reality
it does not contain a value of type \ensuremath{\Varid{x}} at all: it is a function from
a \ensuremath{\Conid{KeyMap}} to a value of type \ensuremath{\Varid{x}}. Hence we can be sure that
arrow computations returning a \ensuremath{\Conid{Cage}} do not allow pattern-matching on the result,
% we do not allow pattern matching on the result of an arrow
% computation
because the result is simply not available. The expression \ensuremath{(\mathbin{+})\fmap\Varid{x}\app\Varid{y}}  we saw earlier in the function \ensuremath{\Varid{addA}}, uses the \ensuremath{\Conid{Applicative}} instance of \ensuremath{\Conid{Cage}}s. 

In our construction, we use \ensuremath{\Conid{Key}}s as names, and \ensuremath{\Conid{KeyMap}}s as
\emph{environments}, i.e. mappings from names to values.  Each result
of an arrow via \ensuremath{(\prec)} has its own name. A \ensuremath{\Conid{Cage}} stands for an
expression, i.e. a function from environment to value, which may
lookup names in the environment. As seen before, the Key monad in
conjunction with \ensuremath{\Conid{KeyMap}}s allows us to model \emph{heterogeneous} environments which can be extended \emph{without changing} the \emph{type} of the environment, which is exactly the extra power we need to define this translation. 

By using \ensuremath{(\prec)} and the monad interface, we can construct the syntax for the arrow computation that we are expressing. Afterwards, we use the following function to convert the syntax to an arrow:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{proc}\mathbin{::}{}\<[10]%
\>[10]{}\Conid{Arrow}\;\Varid{a}\Rightarrow {}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}(\forall\;\Varid{s}.\:\Conid{Cage}\;\Varid{s}\;\Varid{x}\to \Conid{ArrowSyntax}\;\Varid{a}\;\Varid{s}\;(\Conid{Cage}\;\Varid{s}\;\Varid{y})){}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\to \Varid{a}\;\Varid{x}\;\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Internally, the \ensuremath{\Conid{ArrowSyntax}} monad builds an \emph{environment arrow}: an arrow from environment to environment, i.e. an arrow of type \ensuremath{\Varid{a}\;(\Conid{KeyMap}\;\Varid{s})\;(\Conid{KeyMap}\;\Varid{s})}. The \ensuremath{\Conid{ArrowSyntax}} monad creates names for values in these environments using \ensuremath{\Conid{KeyM}}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{newtype}\;\Conid{ArrowSyntax}\;\Varid{a}\;\Varid{s}\;\Varid{x}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Conid{AS}\;(\Conid{WriterT}\;(\Conid{EnvArrow}\;\Varid{a}\;\Varid{s})\;(\Conid{KeyM}\;\Varid{s})\;\Varid{x}){}\<[E]%
\\
\>[5]{}\hsindent{3}{}\<[8]%
\>[8]{}\mathbf{deriving}\;(\Conid{Functor},\Conid{Applicative},\Conid{Monad}){}\<[E]%
\\
\>[B]{}\mathbf{newtype}\;\Conid{EnvArrow}\;\Varid{a}\;\Varid{s}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Conid{EnvArrow}\;(\Varid{a}\;(\Conid{KeyMap}\;\Varid{s})\;(\Conid{KeyMap}\;\Varid{s})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The type declaration for \ensuremath{\Conid{EnvArrow}} suggests that this approach would not have worked if we had used the \st{} monad instead of the Key monad; \ensuremath{\Conid{KeyMap}}s are used as inputs as well as outputs for general arrows, which needs \ensuremath{\Conid{KeyMap}}s to be tangible objects rather than hidden inside a monadic computation, as they are in the \st{} monad.

Like any arrow from a type \ensuremath{\Varid{x}} to the same type, \ensuremath{\Conid{EnvArrow}}s form a monoid as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{instance}\;\Conid{Arrow}\;\Varid{a}\Rightarrow \Conid{Monoid}\;(\Conid{EnvArrow}\;\Varid{a}\;\Varid{x})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{mempty}\mathrel{=}\Conid{EnvArrow}\;(\Varid{arr}\;\Varid{id}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{mappend}\;(\Conid{EnvArrow}\;\Varid{l})\;(\Conid{EnvArrow}\;\Varid{r})\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{5}{}\<[10]%
\>[10]{}\Conid{EnvArrow}\;(\Varid{l}\mathbin{>\!\!\!>\!\!\!>}\Varid{r}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The definition of \ensuremath{\Conid{ArrowSyntax}} uses the standard writer monad transformer, \ensuremath{\Conid{WriterT}}, which produces \ensuremath{\Varid{mempty}} for \ensuremath{\Varid{return}}, and composes the built values from the left and right hand side of \ensuremath{\bind } using \ensuremath{\Varid{mappend}}, giving us precisely what we need for building arrows. 





To define the operations \ensuremath{\Varid{proc}} and \ensuremath{(\prec)}, we first define some auxiliary functions for manipulating environments. 
We can easily convert a name (\ensuremath{\Conid{Key}}) to the expression (\ensuremath{\Conid{Cage}}) which consists of looking up that name in the environment:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{toCage}\mathbin{::}\Conid{Key}\;\Varid{s}\;\Varid{a}\to \Conid{Cage}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{toCage}\;\Varid{k}\mathrel{=}\Conid{Cage}\;(\lambda \Varid{env}\to \Varid{env}\mathbin{!}\Varid{k}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We can introduce an environment from a single value, when given a name (\ensuremath{\Conid{Key}}) for that value: 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{introEnv}\mathbin{::}\Conid{Arrow}\;\Varid{a}\Rightarrow \Conid{Key}\;\Varid{s}\;\Varid{x}\to \Varid{a}\;\Varid{x}\;(\Conid{KeyMap}\;\Varid{s}){}\<[E]%
\\
\>[B]{}\Varid{introEnv}\;\Varid{k}\mathrel{=}\Varid{arr}\;(\lambda \Varid{v}\to \Varid{insert}\;\Varid{k}\;\Varid{v}\;\Varid{empty}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We also define an arrow to eliminate an environment, by interpreting an expression (\ensuremath{\Conid{Cage}}) using that environment:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{elimEnv}\mathbin{::}\Conid{Arrow}\;\Varid{a}\Rightarrow \Conid{Cage}\;\Varid{s}\;\Varid{x}\to \Varid{a}\;(\Conid{KeyMap}\;\Varid{s})\;\Varid{x}{}\<[E]%
\\
\>[B]{}\Varid{elimEnv}\;\Varid{c}\mathrel{=}\Varid{arr}\;(\Varid{open}\;\Varid{c}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Apart from functions to introduce and eliminate environments, we also need functions to extend an environment and to evaluate an expression while keeping the environment:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{extendEnv}\mathbin{::}\Conid{Arrow}\;\Varid{a}\Rightarrow {}\<[26]%
\>[26]{}\Conid{Key}\;\Varid{s}\;\Varid{x}\to {}\<[E]%
\\
\>[26]{}\Varid{a}\;(\Varid{x},\Conid{KeyMap}\;\Varid{s})\;(\Conid{KeyMap}\;\Varid{s}){}\<[E]%
\\
\>[B]{}\Varid{extendEnv}\;\Varid{k}\mathrel{=}\Varid{arr}\;(\Varid{uncurry}\;(\Varid{insert}\;\Varid{k})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{withEnv}\mathbin{::}\Conid{Arrow}\;\Varid{a}\Rightarrow {}\<[24]%
\>[24]{}\Conid{Cage}\;\Varid{s}\;\Varid{x}\to {}\<[E]%
\\
\>[24]{}\Varid{a}\;(\Conid{KeyMap}\;\Varid{s})\;(\Varid{x},\Conid{KeyMap}\;\Varid{s}){}\<[E]%
\\
\>[B]{}\Varid{withEnv}\;\Varid{c}\mathrel{=}\Varid{dup}\mathbin{>\!\!\!>\!\!\!>}\Varid{first}\;(\Varid{elimEnv}\;\Varid{c}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{dup}\mathrel{=}\Varid{arr}\;(\lambda \Varid{x}\to (\Varid{x},\Varid{x})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

With these auxiliary arrows, we can define functions that convert back and forth between a regular arrow and an environment arrow. To implement \ensuremath{(\prec)}, we need to convert a regular arrow to an environment arrow, for which we need an expression for the input to the arrow, and a name for the output of the arrow:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{toEnvArrow}\mathbin{::}{}\<[16]%
\>[16]{}\Conid{Arrow}\;\Varid{a}\Rightarrow {}\<[E]%
\\
\>[B]{}\hsindent{12}{}\<[12]%
\>[12]{}\Conid{Cage}\;\Varid{s}\;\Varid{x}{}\<[22]%
\>[22]{}\to \Conid{Key}\;\Varid{s}\;\Varid{y}\to {}\<[E]%
\\
\>[B]{}\hsindent{12}{}\<[12]%
\>[12]{}\Varid{a}\;\Varid{x}\;\Varid{y}\to \Conid{EnvArrow}\;\Varid{a}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\Varid{toEnvArrow}\;\Varid{inC}\;\Varid{outK}\;\Varid{a}{}\<[24]%
\>[24]{}\mathrel{=}\Conid{EnvArrow}\mathbin{\$}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{withEnv}\;\Varid{inC}\mathbin{>\!\!\!>\!\!\!>}\Varid{first}\;\Varid{a}\mathbin{>\!\!\!>\!\!\!>}\Varid{extendEnv}\;\Varid{outK}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We first produce the input to the argument arrow, by interpreting the input expression using the input environment. We then execute the argument arrow, and bind its output to the given name to obtain the output environment. 

The (\ensuremath{\prec}) operation gets the arrow and the input expression as an argument, creates a name for the output, and then passes these three to \ensuremath{\Varid{toEnvArrow}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\prec)\mathbin{::}\Conid{Arrow}\;\Varid{a}\Rightarrow {}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}\Varid{a}\;\Varid{x}\;\Varid{y}\to {}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}(\Conid{Cage}\;\Varid{s}\;\Varid{x}\to \Conid{ArrowSyntax}\;\Varid{a}\;\Varid{s}\;(\Conid{Cage}\;\Varid{s}\;\Varid{y})){}\<[E]%
\\
\>[B]{}\Varid{a}\prec\Varid{inC}\mathrel{=}\Conid{AS}\mathbin{\$}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mathbf{do}\;{}\<[8]%
\>[8]{}\Varid{outK}\leftarrow \Varid{lift}\;\Varid{newKey}{}\<[E]%
\\
\>[8]{}\Varid{tell}\;(\Varid{toEnvArrow}\;\Varid{inC}\;\Varid{outK}\;\Varid{a}){}\<[E]%
\\
\>[8]{}\Varid{return}\;(\Varid{toCage}\;\Varid{outK}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In the other direction, to implement \ensuremath{\Varid{proc}} we need to convert an environment arrow to a regular arrow, for which we instead need the name of the input and an expression for the output:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}c<{\hspost}@{}}%
\column{37E}{@{}l@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fromEnvArrow}\mathbin{::}{}\<[18]%
\>[18]{}\Conid{Arrow}\;\Varid{a}\Rightarrow {}\<[E]%
\\
\>[B]{}\hsindent{14}{}\<[14]%
\>[14]{}\Conid{Key}\;\Varid{s}\;\Varid{x}{}\<[24]%
\>[24]{}\to \Conid{Cage}\;\Varid{s}\;\Varid{y}\to {}\<[E]%
\\
\>[B]{}\hsindent{14}{}\<[14]%
\>[14]{}\Conid{EnvArrow}\;\Varid{a}\;\Varid{s}\to \Varid{a}\;\Varid{x}\;\Varid{y}{}\<[E]%
\\
\>[B]{}\Varid{fromEnvArrow}\;\Varid{inK}\;\Varid{outC}\;(\Conid{EnvArrow}\;\Varid{a}){}\<[37]%
\>[37]{}\mathrel{=}{}\<[37E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{introEnv}\;\Varid{inK}\mathbin{>\!\!\!>\!\!\!>}\Varid{a}\mathbin{>\!\!\!>\!\!\!>}\Varid{elimEnv}\;\Varid{outC}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We first bind the input to the given name to obtain the input environment. We then transform this environment to the output environment by running the arrow from environment to environment. Finally, we interpret the output expression in the output environment to obtain the output.

The \ensuremath{\Varid{proc}} operation creates a name for the input and passes it to the function as an expression to obtain the output expression and the environment arrow. We then convert the obtained arrow from environment to environment using \ensuremath{\Varid{fromEnvArrow}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{proc}\mathbin{::}{}\<[10]%
\>[10]{}\Conid{Arrow}\;\Varid{a}\Rightarrow {}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}(\forall\;\Varid{s}.\:\Conid{Cage}\;\Varid{s}\;\Varid{x}\to \Conid{ArrowSyntax}\;\Varid{a}\;\Varid{s}\;(\Conid{Cage}\;\Varid{s}\;\Varid{y}))\to {}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{a}\;\Varid{x}\;\Varid{y}{}\<[E]%
\\
\>[B]{}\Varid{proc}\;\Varid{f}\mathrel{=}\Varid{runKeyM}\mathbin{\$}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\mathbf{do}\;{}\<[11]%
\>[11]{}\Varid{inK}\leftarrow \Varid{newKey}{}\<[E]%
\\
\>[11]{}\mathbf{let}\;\Conid{AS}\;\Varid{m}\mathrel{=}\Varid{f}\;(\Varid{toCage}\;\Varid{inK}){}\<[E]%
\\
\>[11]{}(\Varid{outC},\Varid{a})\leftarrow \Varid{runWriterT}\;\Varid{m}{}\<[E]%
\\
\>[11]{}\Varid{return}\;(\Varid{fromEnvArrow}\;\Varid{inK}\;\Varid{outC}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Discussion}

Altenkirch, Chapman and Uustalu~\cite{relmonad} show a related construction: in category theory arrows are a special case of \emph{relative monads}, which are themselves a generalization of monads. In Haskell, a relative monad is an instance of the following type class:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{class}\;\Conid{RelativeMonad}\;\Varid{m}\;\Varid{v}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{rreturn}{}\<[12]%
\>[12]{}\mathbin{::}\Varid{v}\;\Varid{x}\to \Varid{m}\;\Varid{x}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\cdot\!\!\!\bind){}\<[12]%
\>[12]{}\mathbin{::}\Varid{m}\;\Varid{x}\to (\Varid{v}\;\Varid{x}\to \Varid{m}\;\Varid{y})\to \Varid{m}\;\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The only difference with regular monads is that the values resulting from computations must be wrapped in a type constructor \ensuremath{\Varid{v}}, instead of being ``bare''. The relative monad laws are also the same as the regular (Haskell) monad laws.
The construction of Altenkirch et al. which shows that arrows are an instance of relative monads is not a relative monad in Haskell, only in category theory. In particular their construction uses the Yoneda embedding, which does not allow us freely use bound values, instead it requires us to manually lift values into scope, in the same fashion as directly using de Bruijn indices. 

Because all the operations in \ensuremath{\Conid{ArrowSyntax}} (namely \ensuremath{(\prec)}) return a \ensuremath{\Conid{Cage}}, it might be more informative to see it as a relative monad, i.e.:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{ArrowRM}\;\Varid{a}\;\Varid{s}\;\Varid{x}\mathrel{=}\Conid{ArrowRM}{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\Conid{ArrowSyntax}\;\Varid{a}\;\Varid{s}\;(\Conid{Cage}\;\Varid{s}\;\Varid{x})){}\<[E]%
\\
\>[B]{}\mathbf{instance}\;\Conid{RelativeMonad}\;(\Conid{ArrowRM}\;\Varid{a}\;\Varid{s})\;(\Conid{Cage}\;\Varid{s}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}(\prec)\mathbin{::}\Varid{a}\;\Varid{x}\;\Varid{y}\to \Conid{Cage}\;\Varid{s}\;\Varid{x}\to \Conid{ArrowRM}\;\Varid{a}\;\Varid{s}\;\Varid{y}{}\<[E]%
\\
\>[B]{}\Varid{proc}\mathbin{::}(\forall\;\Varid{a}.\:\Conid{Cage}\;\Varid{s}\;\Varid{x}\to \Conid{ArrowRM}\;\Varid{a}\;\Varid{s}\;\Varid{y})\to \Varid{a}\;\Varid{x}\;\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
In this formulation, it is clear that the user cannot decide what to do next based on the outcome of a computation: all we can get from a computation is \ensuremath{\Conid{Cage}}s. 
The monadic interface does not add extra power: while we cannot decide what to do next based on the output of a computation of type \ensuremath{\Conid{ArrowSyntax}\;\Varid{s}\;(\Conid{Cage}\;\Varid{s}\;\Varid{x})}, we can, for example, decide what to next based on the outcome of a computation of type \ensuremath{\Conid{ArrowSyntax}\;\Varid{s}\;\Conid{Int}}. This does not give our embedded arrow notation more power than regular arrow notation or the relative monad interface: the value of the integer cannot depend on the result of an arrow computation and hence must be the result of a pure computation. This is essentially the same trick as described in Svenningsson and Svensson\cite{bjorn}. 

As an aside, more generally, this trick can be used to give a monadic interface for \emph{any} relative monad:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{RelativeMSyntax}\;\Varid{rm}\;\Varid{v}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Conid{Pure}\mathbin{::}\Varid{a}\to \Conid{RelativeMSyntax}\;\Varid{rm}\;\Varid{v}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Conid{Unpure}\mathbin{::}{}\<[15]%
\>[15]{}\Varid{rm}\;\Varid{a}\to (\Varid{v}\;\Varid{a}\to \Conid{RelativeMSyntax}\;\Varid{rm}\;\Varid{v}\;\Varid{b}){}\<[E]%
\\
\>[15]{}\to \Conid{RelativeMSyntax}\;\Varid{rm}\;\Varid{v}\;\Varid{b}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Monad}\;(\Conid{RelativeMSyntax}\;\Varid{rm}\;\Varid{v})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{return}\mathrel{=}\Conid{Pure}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\Conid{Pure}\;\Varid{x})\bind \Varid{f}\mathrel{=}\Varid{f}\;\Varid{x}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\Conid{Unpure}\;\Varid{m}\;\Varid{f})\bind \Varid{g}\mathrel{=}\Conid{Unpure}\;\Varid{m}\;(\lambda \Varid{x}\to \Varid{f}\;\Varid{x}\bind \Varid{g}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{fromRelativeM}\mathbin{::}\Conid{RelativeMonad}\;\Varid{rm}\;\Varid{v}\Rightarrow {}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{rm}\;\Varid{a}\to \Conid{RelativeMSyntax}\;\Varid{rm}\;\Varid{v}\;(\Varid{v}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Varid{fromRelativeM}\;\Varid{m}\mathrel{=}\Conid{Unpure}\;\Varid{m}\;\Varid{return}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{toRelativeM}\mathbin{::}\Conid{RelativeMonad}\;\Varid{rm}\;\Varid{v}\Rightarrow {}\<[E]%
\\
\>[B]{}\hsindent{19}{}\<[19]%
\>[19]{}\Conid{RelativeMSyntax}\;\Varid{rm}\;\Varid{v}\;(\Varid{v}\;\Varid{a})\to \Varid{rm}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{toRelativeM}\;(\Conid{Pure}\;\Varid{x}){}\<[27]%
\>[27]{}\mathrel{=}\Varid{rreturn}\;\Varid{x}{}\<[E]%
\\
\>[B]{}\Varid{toRelativeM}\;(\Conid{Unpure}\;\Varid{m}\;\Varid{f}){}\<[27]%
\>[27]{}\mathrel{=}\Varid{m}\cdot\!\!\!\bind(\Varid{toRelativeM}\circ\Varid{f}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The insight is that because a computation must eventually return a value of \ensuremath{\Varid{v}\;\Varid{a}} to convert a relative monad computation via \ensuremath{\Varid{toRelativeM}}, any pure value that is used, can eventually be removed via the monad law \ensuremath{\Varid{return}\;\Varid{x}\bind \Varid{f}\equiv \Varid{f}\;\Varid{x}}. Our embedded arrow construction can be seen as a relative monad, where we apply this trick to obtain a monadic interface.

Our construction hence suggests that arrows are also a special case of relative monad in Haskell with the key monad, but a formal proof (using the Key monad laws from Figure \ref{laws}) is outside the scope of this paper. In the code online, we also show that this construction can be extended to use \emph{relative monadfix} (with function  \ensuremath{\Varid{rmfix}\mathbin{::}(\Varid{v}\;\Varid{a}\to \Varid{m}\;\Varid{a})\to \Varid{m}\;\Varid{a}}) to construct arrows using \ensuremath{\Conid{ArrowLoop}}, but we cannot use recursive monad notation in this case, because the above trick does not extend to Monadfix.


The \emph{Arrow Calculus}\cite{arrowcalc} describes a translation of a form of arrow syntax (not embedded in Haskell) to arrows which is very similar to the construction presented here. Their calculus has five laws, three of which can be considered to be relative monad laws, which they use to prove the equational correspondence between their calculus and regular arrows. Due to the similarity, their paper should provide a good starting point for anyone trying to prove the same for this construction.

\section{Representations of Variables in Syntax}
\label{syntax}
What else can we do with the Key monad? The Key monad allows us to associate types with ``names'' (\ensuremath{\Conid{Key}}s), and to see that if two names are the same, then their associated types are also the same. Use cases for this especially pop up when dealing with representations of syntax with binders, as we will show next.

\subsection{Typed Names}

A straightforward way to represent the syntax of a programming language is to simply use strings or integers as names. For example, the untyped lambda calculus can be represented as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}c<{\hspost}@{}}%
\column{12E}{@{}l@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Name}{}\<[12]%
\>[12]{}\mathrel{=}{}\<[12E]%
\>[15]{}\Conid{Int}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{Exp}{}\<[12]%
\>[12]{}\mathrel{=}{}\<[12E]%
\>[15]{}\Conid{Var}\;\Conid{Name}{}\<[E]%
\\
\>[12]{}\mid {}\<[12E]%
\>[15]{}\Conid{Lam}\;\Conid{Name}\;\Conid{Exp}{}\<[E]%
\\
\>[12]{}\mid {}\<[12E]%
\>[15]{}\Conid{App}\;\Conid{Exp}\;\Conid{Exp}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
If we want to represent a \emph{typed} representation of the lambda calculus, then this approach does not work anymore. Consider the following \gadt{}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{TExp}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Var}{}\<[8]%
\>[8]{}\mathbin{::}\Conid{Name}\to \Conid{TExp}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Lam}{}\<[8]%
\>[8]{}\mathbin{::}\Conid{Name}\to \Conid{TExp}\;\Varid{b}\to \Conid{TExp}\;(\Varid{a}\to \Varid{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{App}{}\<[8]%
\>[8]{}\mathbin{::}\Conid{TExp}\;(\Varid{a}\to \Varid{b})\to \Conid{TExp}\;\Varid{a}\to \Conid{TExp}\;\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We cannot do much with this datatype. If we, for example, want to write an interpreter, then there is no way to represent the environment: we need to map names to values of different types, but there is no type-safe way to do so.

We could add an extra argument to \ensuremath{\Conid{Var}} and \ensuremath{\Conid{Lam}} containing the type-representation of the type of the variable, obtained using \ensuremath{\Conid{Typeable}}. With the Key monad, we extend this simple naming approach to typed representations without adding \ensuremath{\Conid{Typeable}} constraints. Consider the following data type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}c<{\hspost}@{}}%
\column{9E}{@{}l@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{KExp}\;\Varid{s}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{KVar}{}\<[9]%
\>[9]{}\mathbin{::}{}\<[9E]%
\>[13]{}\Conid{Key}\;\Varid{s}\;\Varid{a}\to \Conid{KExp}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{KLam}{}\<[9]%
\>[9]{}\mathbin{::}{}\<[9E]%
\>[13]{}\Conid{Key}\;\Varid{s}\;\Varid{a}\to \Conid{KExp}\;\Varid{s}\;\Varid{b}\to \Conid{KExp}\;\Varid{s}\;(\Varid{a}\to \Varid{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{KApp}{}\<[9]%
\>[9]{}\mathbin{::}{}\<[9E]%
\>[13]{}\Conid{KExp}\;\Varid{s}\;(\Varid{a}\to \Varid{b})\to \Conid{KExp}\;\Varid{s}\;\Varid{a}\to \Conid{KExp}\;\Varid{s}\;\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Because the names are now represented as keys, we can represent an environment as a \ensuremath{\Conid{KeyMap}}. We can even offer a Higher Order Abstract Syntax (\hoas{}) \cite{hoas} interface for constructing such terms by threading the key monad computation, which guarantees that all terms constructed with this interface are well-scoped:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{class}\;\Conid{Hoas}\;\Varid{f}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{lam}\mathbin{::}(\Varid{f}\;\Varid{a}\to \Varid{f}\;\Varid{b}){}\<[24]%
\>[24]{}\to \Varid{f}\;(\Varid{a}\to \Varid{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{app}\mathbin{::}\Varid{f}\;(\Varid{a}\to \Varid{b}){}\<[24]%
\>[24]{}\to (\Varid{f}\;\Varid{a}\to \Varid{f}\;\Varid{b}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{newtype}\;\Conid{HoasKey}\;\Varid{s}\;\Varid{a}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{HK}\;\{\mskip1.5mu \Varid{getExp}\mathbin{::}\Conid{KeyM}\;\Varid{s}\;(\Conid{KExp}\;\Varid{s}\;\Varid{a})\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Hoas}\;(\Conid{HoasKey}\;\Varid{s})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{lam}\;\Varid{f}\mathrel{=}\Conid{HK}\mathbin{\$}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\mathbf{do}\;{}\<[10]%
\>[10]{}\Varid{k}\leftarrow \Varid{newKey}{}\<[E]%
\\
\>[10]{}\Varid{b}\leftarrow \Varid{getExp}\mathbin{\$}\Varid{f}\mathbin{\$}\Conid{HK}\mathbin{\$}\Varid{pure}\mathbin{\$}\Conid{KVar}\;\Varid{k}{}\<[E]%
\\
\>[10]{}\Varid{return}\;(\Conid{KLam}\;\Varid{k}\;\Varid{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{app}\;\Varid{f}\;\Varid{x}{}\<[12]%
\>[12]{}\mathrel{=}\Conid{HK}\mathbin{\$}\Conid{KApp}\fmap\Varid{getExp}\;\Varid{f}\app\Varid{getExp}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
For instance, the lambda term \ensuremath{(\lambda \Varid{x}\;\Varid{y}\to \Varid{x})} can now be constructed with: \ensuremath{\Varid{lam}\;(\lambda \Varid{x}\to \Varid{lam}\;(\lambda \Varid{y}\to \Varid{x}))}.

Note that we only need the Key monad to {\em create} keys. Once we have created the necessary keys, we can stay fully within normal, non-monadic Haskell. The above example can also be done with the \st{} monad (using \ensuremath{\Conid{STRef}}s as names), but we would have to perform every computation that would do something with these names (for example an interpreter) inside the \st{} monad.

\subsection{Translating Well-scoped Representations}

The datatype \ensuremath{\Conid{KExp}} does not ensure that any value of type \ensuremath{\Conid{KExp}} is well-scoped. There are two well-known approaches to constructing data types for syntax which ensure that every value is well-scoped.  The first is parametric Higher Order Abstract Syntax (\hoas{}) \cite{phoas, ags, graphs}, and the second is using typed de Bruijn indices \cite{nested}.

Previous work~\citep{Atkey2009syntaxff, Atkey09unembedding} has shown how to translate parametric \hoas{} terms to terms with typed de Bruijn indices by relying on parametricty. Interestingly, it seems there is no type-safe way to do this in Haskell without adding \ensuremath{\Conid{Typeable}} constraints to the \ensuremath{\Conid{Phoas}} datatype or using \ensuremath{\Varid{unsafeCoerce}}. The Key monad does allow us to cross this chasm.

In parametric \hoas{}, typed lambda terms are represented by the following data type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Phoas}\;\Varid{v}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{PVar}{}\<[9]%
\>[9]{}\mathbin{::}\Varid{v}\;\Varid{a}\to \Conid{Phoas}\;\Varid{v}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{PLam}{}\<[9]%
\>[9]{}\mathbin{::}(\Varid{v}\;\Varid{a}\to \Conid{Phoas}\;\Varid{v}\;\Varid{b})\to \Conid{Phoas}\;\Varid{v}\;(\Varid{a}\to \Varid{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{PApp}{}\<[9]%
\>[9]{}\mathbin{::}\Conid{Phoas}\;\Varid{v}\;(\Varid{a}\to \Varid{b})\to \Conid{Phoas}\;\Varid{v}\;\Varid{a}\to \Conid{Phoas}\;\Varid{v}\;\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The reading of the type parameter \ensuremath{\Varid{v}} is the type of \emph{variables}.
For example, the lambda term \ensuremath{(\lambda \Varid{x}\;\Varid{y}\to \Varid{x})} can be constructed as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{phoasExample}\mathbin{::}\Conid{Phoas}\;\Varid{v}\;(\Varid{x}\to \Varid{y}\to \Varid{x}){}\<[E]%
\\
\>[B]{}\Varid{phoasExample}\mathrel{=}\Conid{PLam}\;(\lambda \Varid{x}\to \Conid{PLam}\;(\lambda \Varid{y}\to \Varid{x})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
An attractive property of parametric \hoas{} is that we use Haskell binding to construct syntax, and that terms of type \ensuremath{(\forall\;\Varid{v}.\:\Conid{Phoas}\;\Varid{v}\;\Varid{a})} are always well-scoped \cite{phoas}.

The second way to ensure well-scopedness is to use typed de Bruijn indices. Here, we present our own modern variant of this technique using Data Kinds and \gadt s, but the idea is essentially the same as presented by Bird and Paterson \cite{nested}. Our representation of typed de Bruijn indices is an index in a heterogeneous list (Figure\ \ref{heteros}). A typed de Bruijn index of type \ensuremath{\Conid{Index}\;\Varid{l}\;\Varid{a}} is an index for a variable of type \ensuremath{\Varid{a}} in an environment where the types of the variables are represented by the type level list \ensuremath{\Varid{l}}. We can use these indices to represent lambda terms as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Bruijn}\;\Varid{l}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{BVar}{}\<[9]%
\>[9]{}\mathbin{::}\Conid{Index}\;\Varid{l}\;\Varid{a}\to \Conid{Bruijn}\;\Varid{l}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{BLam}{}\<[9]%
\>[9]{}\mathbin{::}\Conid{Bruijn}\;(\Varid{a}\mathbin{:}\Varid{l})\;\Varid{b}\to \Conid{Bruijn}\;\Varid{l}\;(\Varid{a}\to \Varid{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{BApp}{}\<[9]%
\>[9]{}\mathbin{::}\Conid{Bruijn}\;\Varid{l}\;(\Varid{a}\to \Varid{b})\to \Conid{Bruijn}\;\Varid{l}\;\Varid{a}\to \Conid{Bruijn}\;\Varid{l}\;\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
A closed term of type \ensuremath{\Varid{a}} has type \ensuremath{\Conid{Bruijn}\;[\mskip1.5mu \mskip1.5mu]\;\Varid{a}}.

\begin{figure}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Index}\;\Varid{l}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Head}{}\<[9]%
\>[9]{}\mathbin{::}\Conid{Index}\;(\Varid{h}\mathbin{:}\Varid{t})\;\Varid{h}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Tail}{}\<[9]%
\>[9]{}\mathbin{::}\Conid{Index}\;\Varid{t}\;\Varid{x}\to \Conid{Index}\;(\Varid{h}\mathbin{:}\Varid{t})\;\Varid{x}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{data}\;\Conid{TList}\;\Varid{l}\;\Varid{f}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{TNil}{}\<[9]%
\>[9]{}\mathbin{::}\Conid{TList}\;[\mskip1.5mu \mskip1.5mu]\;\Varid{f}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}(\mathbin{:::})\mathbin{::}\Varid{f}\;\Varid{h}\to \Conid{TList}\;\Varid{t}\;\Varid{f}\to \Conid{TList}\;(\Varid{h}\mathbin{:}\Varid{t})\;\Varid{f}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{index}\mathbin{::}\Conid{TList}\;\Varid{l}\;\Varid{f}\to \Conid{Index}\;\Varid{l}\;\Varid{a}\to \Varid{f}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{index}\;(\Varid{h}\mathbin{:::}\anonymous )\;\Conid{Head}{}\<[26]%
\>[26]{}\mathrel{=}\Varid{h}{}\<[E]%
\\
\>[B]{}\Varid{index}\;(\anonymous \mathbin{:::}\Varid{t})\;(\Conid{Tail}\;\Varid{i})\mathrel{=}\Varid{index}\;\Varid{t}\;\Varid{i}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{FFunctor}\;(\Conid{TList}\;\Varid{l})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{ffmap}\;\Varid{f}\;\Conid{TNil}{}\<[21]%
\>[21]{}\mathrel{=}\Conid{TNil}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{ffmap}\;\Varid{f}\;(\Varid{h}\mathbin{:::}\Varid{t})\mathrel{=}\Varid{f}\;\Varid{h}\mathbin{:::}\Varid{ffmap}\;\Varid{f}\;\Varid{t}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{Heterogeneous list and indexes in them.}
\label{heteros}
\end{figure}

The types \ensuremath{(\forall\;\Varid{v}.\:\Conid{Phoas}\;\Varid{v}\;\Varid{a})} and \ensuremath{(\Conid{Bruijn}\;[\mskip1.5mu \mskip1.5mu]\;\Varid{a})} both represent well-scoped typed lambda terms (and \ensuremath{\bot }), and translating from the latter to the former is straightforward. However, there currently seems to be no way to translate the former to the latter (without using the Key monad). In other words there seems to be no function of type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{phoasToBruijn}\mathbin{::}(\forall\;\Varid{v}.\:\Conid{Phoas}\;\Varid{v}\;\Varid{a})\to \Conid{Bruijn}\;[\mskip1.5mu \mskip1.5mu]\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
This seems to be impossible not only in Haskell without extensions, but in dependently typed languages without extensions as well. For example, when using \ensuremath{\Conid{Phoas}} in \emph{Coq} to prove properties about programming languages, a small extension to the logic in the form of a special well-scopedness axiom for the \ensuremath{\Conid{Phoas}} data type is needed to translate Phoas to de Bruijn indices\cite{phoas}.

The well-scopedness of a \ensuremath{\Conid{Bruijn}} value follows from the fact that the value is well-typed. With \ensuremath{\Conid{Phoas}}, the well-scopedness relies on the meta-level (i.e. not formalized through types) argument that no ill-scoped values can be created using the \ensuremath{\Conid{Phoas}} interface. The internal (i.e. formalized through types) well-scopedness of \ensuremath{\Conid{Bruijn}}, allows interpretations of syntax which seem to not be possible if we are using terms constructed with \ensuremath{\Conid{Phoas}}. As an example of this, consider translating lambda terms to \emph{Cartesian closed category} combinators (the categorical version of the lambda calculus), which is useful for translating lambda terms to hardware \cite{conalccc}. This can be done if the lambda terms are given as \ensuremath{\Conid{Bruijn}} values, as demonstrated in Figure \ref{ccc}. Without the Key monad, there seem to be no way to do the same for terms constructed with the \ensuremath{\Conid{Phoas}} terms, but with the \ensuremath{\Conid{Key}} monad we can for example first translate to de Bruijn indices and then to Cartesian closed categories. 

Our implementation of \ensuremath{\Varid{phoasToBruijn}} works by first translating \ensuremath{\Conid{Phoas}} to the \ensuremath{\Conid{KExp}} from the previous subsection, and then translating that to typed de Bruijn indices. The first step in this translation is straightforwardly defined using the \ensuremath{\Conid{Hoas}} interface from the previous subsection: 
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{phoasToKey}\mathbin{::}{}\<[16]%
\>[16]{}(\forall\;\Varid{v}.\:\Conid{Phoas}\;\Varid{v}\;\Varid{a})\to \Conid{KeyM}\;\Varid{s}\;(\Conid{KExp}\;\Varid{s}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Varid{phoasToKey}\;\Varid{v}\mathrel{=}\Varid{getExp}\;(\Varid{go}\;\Varid{v})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{go}\mathbin{::}\Conid{Phoas}\;(\Conid{HoasKey}\;\Varid{s})\;\Varid{a}\to \Conid{HoasKey}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{go}\;(\Conid{PVar}\;\Varid{v}){}\<[18]%
\>[18]{}\mathrel{=}\Varid{v}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{go}\;(\Conid{PLam}\;\Varid{f}){}\<[18]%
\>[18]{}\mathrel{=}\Varid{lam}\;(\Varid{go}\circ\Varid{f}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{go}\;(\Conid{PApp}\;\Varid{f}\;\Varid{x}){}\<[18]%
\>[18]{}\mathrel{=}\Varid{app}\;(\Varid{go}\;\Varid{f})\;(\Varid{go}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We will now show how we can create a function of type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{keyToBruijn}\mathbin{::}\Conid{KExp}\;\Varid{s}\;\Varid{a}\to \Conid{Bruijn}\;[\mskip1.5mu \mskip1.5mu]\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Using this function, we can then implement \ensuremath{\Varid{phoasToBruijn}} as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{phoasToBruijn}\mathbin{::}(\forall\;\Varid{v}.\:\Conid{Phoas}\;\Varid{v}\;\Varid{x})\to \Conid{Bruijn}\;[\mskip1.5mu \mskip1.5mu]\;\Varid{x}{}\<[E]%
\\
\>[B]{}\Varid{phoasToBruijn}\;\Varid{p}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{runKeyM}\;(\Varid{keyToBruijn}\fmap\Varid{phoasToKey}\;\Varid{p}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
To implement the \ensuremath{\Varid{keyToBruijn}} function, we need a variant of the \ensuremath{\Conid{Box}} we saw in Section 2.1:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{FBox}\;\Varid{s}\;\Varid{f}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{FLock}\mathbin{::}\Conid{Key}\;\Varid{s}\;\Varid{a}\to \Varid{f}\;\Varid{a}\to \Conid{FBox}\;\Varid{s}\;\Varid{f}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{funlock}\mathbin{::}\Conid{Key}\;\Varid{s}\;\Varid{a}\to \Conid{FBox}\;\Varid{s}\;\Varid{f}\to \Conid{Maybe}\;(\Varid{f}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Varid{funlock}\;\Varid{k}\;(\Conid{FLock}\;\Varid{k'}\;\Varid{x})\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{case}\;\Varid{testEquality}\;\Varid{k}\;\Varid{k'}\;\mathbf{of}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Just}\;\Conid{Refl}{}\<[16]%
\>[16]{}\to \Conid{Just}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Conid{Nothing}{}\<[16]%
\>[16]{}\to \Conid{Nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The difference with \ensuremath{\Conid{Box}} is that we now store values of type \ensuremath{\Varid{f}\;\Varid{a}} instead of values of type \ensuremath{\Varid{a}} in the box. We provide a variant of \ensuremath{\Varid{fmap}} for this container:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{class}\;\Conid{FFunctor}\;\Varid{p}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{ffmap}\mathbin{::}(\forall\;\Varid{x}.\:\Varid{f}\;\Varid{x}\to \Varid{g}\;\Varid{x})\to \Varid{p}\;\Varid{f}\to \Varid{p}\;\Varid{g}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{FFunctor}\;(\Conid{FBox}\;\Varid{s})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{ffmap}\;\Varid{f}\;(\Conid{FLock}\;\Varid{k}\;\Varid{x})\mathrel{=}\Conid{FLock}\;\Varid{k}\;(\Varid{f}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 We also need a variant of the \ensuremath{\Conid{KeyMap}}, where we store \ensuremath{\Conid{FBox}}es instead of regular boxes:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{43}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{newtype}\;\Conid{FKeyMap}\;\Varid{s}\;\Varid{f}\mathrel{=}\Conid{FKM}\;[\mskip1.5mu \Conid{FBox}\;\Varid{s}\;\Varid{f}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{empty}{}\<[9]%
\>[9]{}\mathbin{::}\Conid{FKeyMap}\;\Varid{s}\;\Varid{f}{}\<[E]%
\\
\>[B]{}\Varid{insert}{}\<[9]%
\>[9]{}\mathbin{::}\Conid{Key}\;\Varid{s}\;\Varid{a}\to \Varid{f}\;\Varid{a}\to \Conid{FKeyMap}\;\Varid{s}\;\Varid{f}{}\<[43]%
\>[43]{}\to \Conid{FKeyMap}\;\Varid{s}\;\Varid{f}{}\<[E]%
\\
\>[B]{}\Varid{lookup}{}\<[9]%
\>[9]{}\mathbin{::}\Conid{Key}\;\Varid{s}\;\Varid{a}\to \Conid{FKeyMap}\;\Varid{s}\;\Varid{f}\to \Conid{Maybe}\;(\Varid{f}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\mathbf{instance}\;\Conid{FFunctor}\;(\Conid{FKeyMap}\;\Varid{s}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

To translate to de Bruijn indices, we store the current ``environment'' as an \ensuremath{\Conid{FKeyMap}} mapping each \ensuremath{\Conid{Key}} to an \ensuremath{\Conid{Index}} in the current environment. When we enter a lambda-body, we need to extend the environment: we add a mapping of the new variable to the de Bruijn index \ensuremath{\Conid{Head}}, and add one lookup step to each other de Bruijn index currently in the \ensuremath{\Conid{FKeyMap}}. This is be done as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{extend}\mathbin{::}{}\<[12]%
\>[12]{}\Conid{Key}\;\Varid{s}\;\Varid{h}\to \Conid{FKeyMap}\;\Varid{s}\;(\Conid{Index}\;\Varid{t})\to {}\<[E]%
\\
\>[12]{}\Conid{FKeyMap}\;\Varid{s}\;(\Conid{Index}\;(\Varid{h}\mathbin{:}\Varid{t})){}\<[E]%
\\
\>[B]{}\Varid{extend}\;\Varid{k}\;\Varid{m}\mathrel{=}\Varid{insert}\;\Varid{k}\;\Conid{Head}\;(\Varid{ffmap}\;\Conid{Tail}\;\Varid{m}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The type of \ensuremath{\Varid{extend}} suggests that we could not have used the \st{} monad instead of the Key monad, because the internal state of the computation (represented by the \ensuremath{\Conid{FKeyMap}}) changes {\em type} after \ensuremath{\Varid{extend}}. To support this in the \st{} monad, we would need the equivalent of \ensuremath{\Varid{ffmap}}, which would map a function over all existing \ensuremath{\Conid{STRef}}s.

With this machinery in place, we can translate \ensuremath{\Conid{KExp}} to \ensuremath{\Conid{Bruijn}} as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{keyToBruijn}\mathbin{::}\Conid{KExp}\;\Varid{s}\;\Varid{a}\to \Conid{Bruijn}\;[\mskip1.5mu \mskip1.5mu]\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{keyToBruijn}\mathrel{=}\Varid{go}\;\Varid{empty}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{go}\mathbin{::}\Conid{FKeyMap}\;\Varid{s}\;(\Conid{Index}\;\Varid{l})\to \Conid{KExp}\;\Varid{s}\;\Varid{x}\to \Conid{Bruijn}\;\Varid{l}\;\Varid{x}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{go}\;\Varid{e}\;(\Conid{KVar}\;\Varid{v}){}\<[20]%
\>[20]{}\mathrel{=}\Conid{BVar}\;(\Varid{e}\mathbin{!}\Varid{v}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{go}\;\Varid{e}\;(\Conid{KLam}\;\Varid{k}\;\Varid{b}){}\<[20]%
\>[20]{}\mathrel{=}\Conid{BLam}\;(\Varid{go}\;(\Varid{extend}\;\Varid{k}\;\Varid{e})\;\Varid{b}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{go}\;\Varid{e}\;(\Conid{KApp}\;\Varid{f}\;\Varid{x}){}\<[20]%
\>[20]{}\mathrel{=}\Conid{BApp}\;(\Varid{go}\;\Varid{e}\;\Varid{f})\;(\Varid{go}\;\Varid{e}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Note that \ensuremath{\Varid{keyToBruijn}} fails if the input \ensuremath{\Conid{KExp}} is ill-scoped. This cannot happen when \ensuremath{\Varid{keyToBruijn}} is called from \ensuremath{\Varid{phoasToBruijn}} because \ensuremath{\Varid{phoasToKey}} will always give well-scoped values of type \ensuremath{\Conid{KExp}}. This relies on the meta-level argument that values of type \ensuremath{\Conid{PHoas}} are always well-scoped. We stress that hence the key monad extension \emph{cannot} serve as a replacement of well-scopedness axiom used in a dependently typed setting. 


\begin{figure}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{class}\;\Conid{Category}\;\Varid{c}\Rightarrow \Conid{CCC}\;\Varid{c}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{prod}{}\<[14]%
\>[14]{}\mathbin{::}\Varid{c}\;\Varid{x}\;\Varid{a}\to \Varid{c}\;\Varid{x}\;\Varid{b}\to \Varid{c}\;\Varid{x}\;(\Varid{a},\Varid{b}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{fst}{}\<[14]%
\>[14]{}\mathbin{::}\Varid{c}\;(\Varid{a},\Varid{b})\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{snd}{}\<[14]%
\>[14]{}\mathbin{::}\Varid{c}\;(\Varid{a},\Varid{b})\;\Varid{b}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{curry}{}\<[14]%
\>[14]{}\mathbin{::}\Varid{c}\;(\Varid{a},\Varid{b})\;\Varid{x}\to \Varid{c}\;\Varid{a}\;(\Varid{b}\to \Varid{x}){}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}\Varid{uncurry}{}\<[14]%
\>[14]{}\mathbin{::}\Varid{c}\;\Varid{a}\;(\Varid{b}\to \Varid{x})\to \Varid{c}\;(\Varid{a},\Varid{b})\;\Varid{x}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{toClosed}\mathbin{::}\Conid{CCC}\;\Varid{c}\Rightarrow {}\<[23]%
\>[23]{}\Conid{Bruijn}\;[\mskip1.5mu \mskip1.5mu]\;(\Varid{x}\to \Varid{y})\to {}\<[E]%
\\
\>[23]{}\Varid{c}\;()\;(\Varid{x}\to \Varid{y}){}\<[E]%
\\
\>[B]{}\Varid{toClosed}\;\Varid{p}\mathrel{=}\Varid{go}\;\Varid{p}\;\Conid{TNil}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{go}\mathbin{::}\Conid{CCC}\;\Varid{c}\Rightarrow \Conid{Bruijn}\;\Varid{l}\;\Varid{y}\to \Conid{TList}\;\Varid{l}\;(\Varid{c}\;\Varid{x})\to \Varid{c}\;\Varid{x}\;\Varid{y}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{go}\;(\Conid{BVar}\;\Varid{x})\;{}\<[18]%
\>[18]{}\Varid{e}\mathrel{=}\Varid{index}\;\Varid{e}\;\Varid{x}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{go}\;(\Conid{BLam}\;\Varid{b})\;{}\<[18]%
\>[18]{}\Varid{e}\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{curry}\mathbin{\$}\Varid{go}\;\Varid{b}\;(\Varid{snd}\mathbin{:::}\Varid{ffmap}\;(\circ\:\Varid{fst})\;\Varid{e}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{go}\;(\Conid{BApp}\;\Varid{f}\;\Varid{x})\;{}\<[18]%
\>[18]{}\Varid{e}\mathrel{=}\Varid{uncurry}\;(\Varid{go}\;\Varid{f}\;\Varid{e})\circ\Varid{prod}\;\Varid{id}\;(\Varid{go}\;\Varid{x}\;\Varid{e}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{FFunctor}\;(\Conid{TList}\;\Varid{l})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{ffmap}\;\Varid{f}\;\Conid{TNil}{}\<[21]%
\>[21]{}\mathrel{=}\Conid{TNil}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{ffmap}\;\Varid{f}\;(\Varid{h}\mathbin{:::}\Varid{t})\mathrel{=}\Varid{f}\;\Varid{h}\mathbin{:::}\Varid{ffmap}\;\Varid{f}\;\Varid{t}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{Translating lambda terms to Cartesian closed categories.}
\label{ccc}
%$
\end{figure}


\section{Safety of the Key Monad}
\label{safety}

In this section, we state more precisely what we mean by safety, and informally argue for the safety of the Key monad.

\subsection{Type Safety}

The first safety property that we conjecture the Key monad has is \emph{type safety}: \ensuremath{\Varid{testEquality}} will never allow us to prove that \ensuremath{\Varid{a}:\sim:\Varid{b}} if \ensuremath{\Varid{a}} and \ensuremath{\Varid{b}} are \emph{distinct} types. Informally, the justification for this is that a key value \ensuremath{\Varid{k}} of type \ensuremath{\Conid{Key}\;\Varid{s}\;\Varid{a}} together with the type \ensuremath{\Varid{s}}, which we call the \emph{scope type variable},  \emph{uniquely determines} the associated type \ensuremath{\Varid{a}} of the key. Hence, when two key values and scope type variables are the same\footnote{Even though users cannot compare keys explicitly, implementations of the Key monad internally represent keys by some underlying value that can be compared for equality.}, their associated types \emph{must be the same} as well. 

The argument why the scope type variable \ensuremath{\Varid{s}} and the key value \ensuremath{\Varid{k}} together uniquely determine type \ensuremath{\Varid{a}} goes as follows:
\begin{enumerate}
\item Each execution of a Key monad computation has a scope type variable \ensuremath{\Varid{s}} that is distinct from the scope type variables of all other Key monad computations. This is ensured by the type of \ensuremath{\Varid{runKeyM}}, namely \ensuremath{(\forall\;\Varid{s}.\:\Conid{KeyM}\;\Varid{s}\;\Varid{a})\to \Varid{a}}, which states that the type \ensuremath{\Varid{s}} cannot be unified with any other type. 
\item Each \ensuremath{\Varid{newKey}} operation in such a Key monad computation gives a value that is unique within the scope determined by \ensuremath{\Varid{s}}, i.e. distinct from other keys created in the same computation.
\item Each key only has \emph{a single type} associated with it. This is ensured by the type of \ensuremath{\Varid{newKey}}, which only allows us to construct a key with a single type, i.e. not a key of type \ensuremath{\forall\;\Varid{a}.\:\Conid{Key}\;\Varid{s}\;\Varid{a}}. The type of a hypothetical function \ensuremath{\Varid{newPolymorphicKey}\mathbin{::}\Conid{KeyM}\;\Varid{s}\;(\forall\;\Varid{a}.\:\Conid{Key}\;\Varid{s}\;\Varid{a})} does not unify with the type of \ensuremath{\Varid{newKey}}. 
\end{enumerate}




\subsection{Referential Transparency} 

The second safety property that we are concerned with is \emph{referential transparency}. More precisely, in an otherwise pure language with the Key monad extension, does the following still hold?
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\mathbf{let}\;\Varid{x}\mathrel{=}\Varid{e}\;\mathbf{in}\;\Varid{f}\;\Varid{x}\;\Varid{x})\equiv \Varid{f}\;\Varid{e}\;\Varid{e}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In other words, referential transparency means that an expression always evaluates to the same result in any context. Our implementation of the key monad only relies on \emph{unsafeCoerce}; it does not use \emph{unsafePerformIO}, nor does it use \ensuremath{\Varid{unsafeCoerce}} to convert an \ensuremath{\Conid{IO}\;\Varid{a}} action to a pure value (if we assume type safety) and hence referential transparency cannot be broken by this implementation. Since the \st{} monad can be implemented using the Key monad, the same can be said for the \st{} monad. 
However, more efficient implementations of the \st{} monad use \emph{global} pointers respectively, which do rely on features that might potentially break referential transparency.


\subsection{Abstraction Safety} 
Abstraction safety is the property that we cannot break the abstraction barriers which are introduced through existential types. For example, consider the following existential type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{AbsBool}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{AbsBool}\mathbin{::}{}\<[15]%
\>[15]{}\Conid{Eq}\;\Varid{a}\Rightarrow \Varid{a}\to \Varid{a}\to (\Varid{a}\to \Varid{b}\to \Varid{b}\to \Varid{b}){}\<[E]%
\\
\>[15]{}\to \Conid{AbsBool}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Let us consider two different uses of this type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}c<{\hspost}@{}}%
\column{10E}{@{}l@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{boolBool}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{AbsBool}\;\Conid{True}\;\Conid{False}\;(\lambda \Varid{c}\;\Varid{t}\;\Varid{f}\to \mathbf{if}\;\Varid{c}\;\mathbf{then}\;\Varid{t}\;\mathbf{else}\;\Varid{f}){}\<[E]%
\\
\>[B]{}\Varid{boolInt}{}\<[10]%
\>[10]{}\mathrel{=}{}\<[10E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{AbsBool}\;{}\<[12]%
\>[12]{}\mathrm{0}\;\mathrm{1}\;{}\<[23]%
\>[23]{}(\lambda \Varid{c}\;\Varid{t}\;\Varid{f}\to \mathbf{if}\;\Varid{c}\equiv \mathrm{0}\;\mathbf{then}\;\Varid{t}\;\mathbf{else}\;\Varid{f}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
If a language is abstraction safe, then it is impossible to observe any difference between \ensuremath{\Varid{boolBool}} and \ensuremath{\Varid{boolInt}}. This property is formalized by \emph{parametricity} (which also gives ``free'' theorems \cite{theoremsforfree}). A typical example of a primitive which is not abstraction safe (but is type-safe) is a primitive that allows us to check the equality of any two types:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{badTest}\mathbin{::}\Varid{a}\to \Varid{b}\to \Conid{Maybe}\;(\Varid{a}:\sim:\Varid{b}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The primitive \ensuremath{\Varid{testEquality}} is similar to the \ensuremath{\Varid{badTest}} primitive above, and indeed our operations on \ensuremath{\Conid{Box}} do allow us to ``break the abstraction barrier'': if \ensuremath{\Varid{unlock}} succeeds, we have learned which type is hidden in the \ensuremath{\Conid{Box}}. However, finding out which type is hidden by an existential type can not only be done with the Key monad, but also by the established Generalized Algebraic Data types extension of Haskell. For example, suppose we have the following type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{IsType}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{IsBool}{}\<[11]%
\>[11]{}\mathbin{::}\Conid{IsType}\;\Conid{Bool}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{IsInt}{}\<[11]%
\>[11]{}\mathbin{::}\Conid{IsType}\;\Conid{Int}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{IsChar}{}\<[11]%
\>[11]{}\mathbin{::}\Conid{IsType}\;\Conid{Char}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We can then straightforwardly implement a variant of \ensuremath{\Varid{testEquality}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{testEquality}\mathbin{::}\Conid{IsType}\;\Varid{a}\to \Conid{IsType}\;\Varid{b}\to \Conid{Maybe}\;(\Varid{a}:\sim:\Varid{b}){}\<[E]%
\\
\>[B]{}\Varid{testEquality}\;\Conid{IsBool}\;{}\<[22]%
\>[22]{}\Conid{IsBool}{}\<[30]%
\>[30]{}\mathrel{=}\Conid{Just}\;\Conid{Refl}{}\<[E]%
\\
\>[B]{}\Varid{testEquality}\;\Conid{IsInt}\;{}\<[22]%
\>[22]{}\Conid{IsInt}{}\<[30]%
\>[30]{}\mathrel{=}\Conid{Just}\;\Conid{Refl}{}\<[E]%
\\
\>[B]{}\Varid{testEquality}\;\Conid{IsChar}\;{}\<[22]%
\>[22]{}\Conid{IsChar}{}\<[30]%
\>[30]{}\mathrel{=}\Conid{Just}\;\Conid{Refl}{}\<[E]%
\\
\>[B]{}\Varid{testEquality}\;\anonymous \;{}\<[22]%
\>[22]{}\anonymous {}\<[30]%
\>[30]{}\mathrel{=}\Conid{Nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

There are, however, formulations of parametricity which state more precisely exactly which abstraction barrier cannot be crossed \cite{type-safecast, bernardy_proofs_2012}. In these formulations, \ensuremath{\Varid{boolBool}} and \ensuremath{\Varid{boolInt}} are indistinguishable. We can think of \ensuremath{\Varid{runKeyM}} as an operation which dreams up a specific Key \gadt{} for the given computation, for example:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Key}\;\Conid{A}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Key0}\mathbin{::}\Conid{Key}\;\Conid{A}\;\Conid{Int}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Key1}\mathbin{::}\Conid{Key}\;\Conid{A}\;\Conid{Bool}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbin{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Here \ensuremath{\Conid{A}} is a globally unique type associated with the computation. This interpretation is a little tricky: since a Key computation might create an infinite number of keys, this hypothetical datatype might have an infinite number of constructors. Alternatively, we can interpret keys as \gadt s that index into a type-level list or type-level tree, as we do in Section \ref{impl}.  We conjecture that there is a variant of parametricity for Haskell extended with the Key monad in which, in analogy with parametricity for \gadt s, \ensuremath{\Varid{boolBool}} and \ensuremath{\Varid{boolInt}} above are considered to be indistinguishable. 


\subsection{Normalization}

A fourth desirable property of a type system extension is preservation of normalization, i.e.,
the property that ensures well-typed terms always have a normal form. 
%What this usually means is that type-safe programs that do not use recursion terminate.
Although standard typed $\lambda$-calculi (such as System F) are normalizing, Haskell is not, as we can write non-terminating programs. Even without term-level recursion, we can create programs that do not terminate by using type-level recursion. However, if we disallow contravariant recursion at the type level (i.e.\ type-level recursive occurrences that occur to the left of a function arrow), then all Haskell programs without term-level recursion do terminate.

It turns out that extending a normalizing language with the Key monad breaks normalization.
%, even when we disallow contravariant recursion on the type level and recursion at the term level. 
We show this by implementing a general fixpoint combinator \ensuremath{\Varid{fix}} which uses neither contravariant recursion at the type level nor term-level recursion.

\begin{figure}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{D}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mathrel{=}{}\<[7]%
\>[7]{}\Conid{Fun}\;(\Conid{Box}\;\Varid{s}\to \Conid{D}\;\Varid{s}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mid {}\<[7]%
\>[7]{}\Conid{Val}\;\Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{lam}\mathbin{::}\Conid{Key}\;\Varid{s}\;(\Conid{D}\;\Varid{s}\;\Varid{a})\to (\Conid{D}\;\Varid{s}\;\Varid{a}\to \Conid{D}\;\Varid{s}\;\Varid{a})\to \Conid{D}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{lam}\;\Varid{k}\;\Varid{f}\mathrel{=}\Conid{Fun}\;(\Varid{f}.\:\Varid{fromJust}.\:\Varid{unlock}\;\Varid{k}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{app}\mathbin{::}\Conid{Key}\;\Varid{s}\;(\Conid{D}\;\Varid{s}\;\Varid{a})\to \Conid{D}\;\Varid{s}\;\Varid{a}\to \Conid{D}\;\Varid{s}\;\Varid{a}\to \Conid{D}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{app}\;\Varid{k}\;(\Conid{Fun}\;\Varid{f})\;\Varid{x}\mathrel{=}\Varid{f}\;(\Conid{Lock}\;\Varid{k}\;\Varid{x}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{fix}\mathbin{::}(\Varid{a}\to \Varid{a})\to \Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{fix}\;\Varid{f}\mathrel{=}\Varid{runKeyM}\mathbin{\$}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mathbf{do}\;{}\<[8]%
\>[8]{}\Varid{k}\leftarrow \Varid{newKey}{}\<[E]%
\\
\>[8]{}\mathbf{let}\;{}\<[13]%
\>[13]{}\Varid{f'}{}\<[19]%
\>[19]{}\mathrel{=}\Varid{lam}\;\Varid{k}\;(\Conid{Val}.\:\Varid{f}.\:\Varid{unVal}){}\<[E]%
\\
\>[13]{}\Varid{xfxx}{}\<[19]%
\>[19]{}\mathrel{=}\Varid{lam}\;\Varid{k}\;(\lambda \Varid{x}\to \Varid{app}\;\Varid{k}\;\Varid{f'}\;(\Varid{app}\;\Varid{k}\;\Varid{x}\;\Varid{x})){}\<[E]%
\\
\>[13]{}\Varid{fixf}{}\<[19]%
\>[19]{}\mathrel{=}\Varid{app}\;\Varid{k}\;\Varid{xfxx}\;\Varid{xfxx}{}\<[E]%
\\
\>[8]{}\Varid{return}\;(\Varid{unVal}\;\Varid{fixf}){}\<[E]%
\\
\>[B]{}\mathbf{where}\;\Varid{unVal}\;(\Conid{Val}\;\Varid{x})\mathrel{=}\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{Implementing a general fixpoint combinator without term-level recursion nor type-level contravariant recursion}
\label{fig:fix}
\end{figure}
%$
Figure\ \ref{fig:fix} presents the implementation of \ensuremath{\Varid{fix}}. First, we introduce a datatype \ensuremath{\Conid{D}\;\Varid{s}\;\Varid{a}} for domains representing models of the untyped lambda calculus. (We are going to encode the standard fixpoint combinator \ensuremath{\lambda \Varid{f}\to (\lambda \Varid{x}\to \Varid{f}\;(\Varid{x}\;\Varid{x}))\;(\lambda \Varid{x}\to \Varid{f}\;(\Varid{x}\;\Varid{x}))} in this domain.) An element of \ensuremath{\Conid{D}\;\Varid{s}\;\Varid{a}} is either a function over \ensuremath{\Conid{D}\;\Varid{s}\;\Varid{a}} or a value of type \ensuremath{\Varid{a}}. Normally, we would use contravariant recursion for the argument of \ensuremath{\Conid{Fun}}, but we are not allowed to, so we mask it by using a \ensuremath{\Conid{Box}\;\Varid{s}} instead. As a result, \ensuremath{\Conid{D}\;\Varid{s}\;\Varid{a}} is not contravariantly recursive, and neither are any of its instances.

Second, we introduce two helper functions: \ensuremath{\Varid{lam}}, which takes a function over the domain, and injects it as an element into the domain, and \ensuremath{\Varid{app}}, which takes two elements of the domain and applies the first argument to the second argument. Both need an extra argument of type \ensuremath{\Conid{Key}\;\Varid{s}\;(\Conid{D}\;\Varid{s}\;\Varid{a})} to lock/unlock the forbidden recursive argument.

Third, the fixpoint combinator takes a Haskell function \ensuremath{\Varid{f}}, wraps it onto the domain \ensuremath{\Conid{D}\;\Varid{s}\;\Varid{a}} resulting in a function \ensuremath{\Varid{f'}}, and then uses \ensuremath{\Varid{lam}} and \ensuremath{\Varid{app}} to construct a fixpoint combinator from the untyped lambda calculus. Lastly, we need to convert the result from the domain \ensuremath{\Conid{D}\;\Varid{s}\;\Varid{a}} back into Haskell-land using \ensuremath{\Varid{unVal}}.

What this shows is that (1) adding the Key monad to a normalizing language may make it non-normalizing, (2) the Key monad is a genuine extension of Haskell without term-level recursion and type-level contravariant recursion. Incidentally, this is also the case for the \st{} monad. In a stratified type system with universe levels, such as Agda or Coq, it should be possible to omit this problem by making keys of a higher level than their associated types. In Haskell, this would defeat the ``unconstrained'' part of the title of the paper; then we could just as well have used \ensuremath{\Conid{Typeable}}.

\section{Implementing the Key Monad}
\label{impl}
Is the Key monad expressible in Haskell directly, without using \ensuremath{\Varid{unsafeCoerce}}? Can we employ more recent advancements such as  \gadt s to ``prove'' to the type system that the Key monad is safe? In this section, we explore how far we can get (and fail).

The question of whether or not the Key monad is implementable in Haskell (with extensions) is related to the question of whether or not the \st{} monad is implementable in Haskell (with extensions): a negative answer to the latter implies a negative answer to the former. The latter question, about \st{}, was (as far as we know) first publicly asked by the second author on the Haskell mailing list in 2001 \cite{koen2001}, accompanied by a proposal of an early version of the Key monad, then called the ``Object monad''. Since then, the question has regularly popped up on online discussion forums (e.g. \cite{reddit}). The question has never been answered positively, which we take as a strong indication that the Key monad is also not implementable in Haskell (with extensions).

\subsection{Implementation Using \ensuremath{\Varid{unsafeCoerce}}}

To get a feel for possible implementations of the Key monad, let us first consider a straightforward implementation, using \emph{unsafeCoerce}, in which we give each key a unique name. One could implement generating unique names using a state monad, but the \ensuremath{(\Varid{purity})} key monad law (\ensuremath{\Varid{m}\sequ \Varid{n}\equiv \Varid{n})} would then not hold. Instead, we implement the Key monad using a splittable name supply~\cite{McBride2004}, with the following interface:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{newNameSupply}{}\<[16]%
\>[16]{}\mathbin{::}\Conid{NameSupply}{}\<[E]%
\\
\>[B]{}\Varid{split}{}\<[16]%
\>[16]{}\mathbin{::}{}\<[20]%
\>[20]{}\Conid{NameSupply}\to {}\<[E]%
\\
\>[20]{}(\Conid{NameSupply},\Conid{NameSupply}){}\<[E]%
\\
\>[B]{}\Varid{supplyName}{}\<[16]%
\>[16]{}\mathbin{::}\Conid{NameSupply}\to \Conid{Name}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

One implementation of the \ensuremath{\Conid{NameSupply}} uses paths in a binary tree:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{TreePath}\mathrel{=}\Conid{Start}\mid \Conid{Left}\;\Conid{TreePath}\mid \Conid{Right}\;\Conid{TreePath}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
When reading left-to-right, these paths are given in reverse order from the root: the path \ensuremath{\Conid{Left}\;(\Conid{Right}\;\Conid{Start})} is a path to the left child of the right child of the root. A name is then a path to leaf in a tree, and a name supply is a path to a subtree. To split a \ensuremath{\Conid{NameSupply}}, we convert a path to a node into a path to the two children of that node:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{NameSupply}{}\<[18]%
\>[18]{}\mathrel{=}\Conid{TreePath}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Name}{}\<[18]%
\>[18]{}\mathrel{=}\Conid{TreePath}{}\<[E]%
\\
\>[B]{}\Varid{newNameSupply}{}\<[16]%
\>[16]{}\mathrel{=}\Conid{Start}{}\<[E]%
\\
\>[B]{}\Varid{split}\;\Varid{s}{}\<[16]%
\>[16]{}\mathrel{=}(\Conid{Left}\;\Varid{s},\Conid{Right}\;\Varid{s}){}\<[E]%
\\
\>[B]{}\Varid{supplyName}{}\<[16]%
\>[16]{}\mathrel{=}\Varid{id}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Using such name supplies, the implementation of the Key monad is as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{KeyM}\;\Varid{s}\;\Varid{a}\mathrel{=}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{KeyM}\;\{\mskip1.5mu \Varid{getKeyM}\mathbin{::}\Conid{NameSupply}\to \Varid{a}\mskip1.5mu\}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\Conid{Key}\;\Varid{s}\;\Varid{a}{}\<[16]%
\>[16]{}\mathrel{=}\Conid{Key}\;\Conid{Name}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{newKey}\mathbin{::}\Conid{KeyM}\;\Varid{s}\;(\Conid{Key}\;\Varid{s}\;\Varid{a}){}\<[E]%
\\
\>[B]{}\Varid{newKey}\mathrel{=}\Conid{KeyM}\mathbin{\$}\lambda \Varid{s}\to \Conid{Key}\;(\Varid{supplyName}\;\Varid{s}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{instance}\;\Conid{Monad}\;(\Conid{KeyM}\;\Varid{s})\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{return}\;\Varid{x}{}\<[17]%
\>[17]{}\mathrel{=}\Conid{KeyM}\mathbin{\$}\mathbin{\char92 \char95 }\to \Varid{x}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{m}\bind \Varid{f}{}\<[17]%
\>[17]{}\mathrel{=}\Conid{KeyM}\mathbin{\$}\lambda \Varid{s}\to {}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\mathbf{let}\;(\Varid{sl},\Varid{sr})\mathrel{=}\Varid{split}\;\Varid{s}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\mathbf{in}\;\Varid{getKeyM}\;(\Varid{f}\;(\Varid{getKeyM}\;\Varid{m}\;\Varid{sl}))\;\Varid{sr}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{runKeyM}\mathbin{::}(\forall\;\Varid{s}.\:\Conid{KeyM}\;\Varid{s}\;\Varid{a})\to \Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{runKeyM}\;(\Conid{KeyM}\;\Varid{f}){}\<[19]%
\>[19]{}\mathrel{=}\Varid{f}\;\Varid{newNameSupply}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{testEquality}\;(\Conid{Key}\;\Varid{l})\;(\Conid{Key}\;\Varid{r}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{l}\equiv \Varid{r}{}\<[16]%
\>[16]{}\mathrel{=}\Conid{Just}\;(\Varid{unsafeCoerce}\;\Conid{Refl}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{otherwise}{}\<[16]%
\>[16]{}\mathrel{=}\Conid{Nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A \ensuremath{\Conid{KeyM}} computation consisting of \ensuremath{\bind },\ensuremath{\Varid{return}} and \ensuremath{\Varid{newKey}} can also be seen as a binary tree where binds are nodes, \ensuremath{\Varid{newKey}}s are leaves and \ensuremath{\Varid{return}}s are empty subtrees. The \ensuremath{\Conid{Name}} associated with each key is the path to the \ensuremath{\Varid{newKey}} that created it, in the tree that corresponds to the \ensuremath{\Conid{KeyM}} computation. For example, the Key resulting from the \ensuremath{\Varid{newKey}} in the expression:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{runKeyM}\mathbin{\$}(\Varid{m}\sequ \Varid{newKey})\bind \Varid{f}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
will get the name \ensuremath{\Conid{Right}\;(\Conid{Left}\;\Conid{Start})}.

Note that the Key monad laws from Figure \ref{laws} only hold for this implementation \emph{up to observation}. If we have access to the definition of Keys, we can discriminate between, for example, \ensuremath{\Varid{m}\sequ \Varid{n}} and \ensuremath{\Varid{n}}. However, in the interface \ensuremath{\Conid{Key}} is an abstract type, and thus users can be blissfully ignorant of this.

A downside of this implementation is that \ensuremath{\Varid{testEquality}} is linear in the length of the tree paths. A more efficient implementation of the Key monad uses \ensuremath{\Conid{Integer}}s to represent keys and deals out unique names by unsafely reading and updating a mutable variable which is unsafely created in \ensuremath{\Varid{runKey}}. A full implementation of this version of the Key monad can be found in the code online.

\subsection{The Key Indexed Monad}

Can we formalize through types the invariant that when two keys are the same their types must also be the same? It turns out we can, but this adds more types to the interface, leading to a loss of power of the construction.

The crucial insight is that is needed for this implementation, is that it \emph{is} possible to implement to compare two indices in a heterogeneous list (Fig \ref{heteros}), and if they are equal, then produce a proof that the types are equal, as follows:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{testEquality}\mathbin{::}\Conid{Index}\;\Varid{l}\;\Varid{a}\to \Conid{Index}\;\Varid{l}\;\Varid{b}\to \Conid{Maybe}\;(\Varid{a}:\sim:\Varid{b}){}\<[E]%
\\
\>[B]{}\Varid{testEquality}\;\Conid{Head}\;{}\<[24]%
\>[24]{}\Conid{Head}{}\<[34]%
\>[34]{}\mathrel{=}\Conid{Just}\;\Conid{Refl}{}\<[E]%
\\
\>[B]{}\Varid{testEquality}\;(\Conid{Tail}\;\Varid{l})\;{}\<[24]%
\>[24]{}(\Conid{Tail}\;\Varid{r}){}\<[34]%
\>[34]{}\mathrel{=}\Varid{testEquality}\;\Varid{l}\;\Varid{r}{}\<[E]%
\\
\>[B]{}\Varid{testEquality}\;\anonymous \;{}\<[24]%
\>[24]{}\anonymous {}\<[34]%
\>[34]{}\mathrel{=}\Conid{Nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We can employ the same insight to construct \ensuremath{\Varid{testEquality}} function for other data types. Instead of indexes in a heterogeneous list, we add types to the paths in a tree to obtain  \emph{paths in a heterogenous tree}. For this datatype we need to be able to construct type-level trees, for which we use the following data type as a data-kind:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Tree}\;\Varid{a}\mathrel{=}\Conid{Empty}\mid \Conid{Single}\;\Varid{a}\mid \Conid{Tree}\;\Varid{a}:\!\!+\!\!\!+\!\!:\Conid{Tree}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
With this datatype, we can construct types of kind \ensuremath{\Conid{Tree}} \ensuremath{\mathbin{*}} such as:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{Single}\;\Conid{Int}:\!\!+\!\!\!+\!\!:(\Conid{Single}\;\Conid{Bool}:\!\!+\!\!\!+\!\!:\Conid{Single}\;\Conid{String}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We can now adapt the datatype \ensuremath{\Conid{TreePath}} to provide paths in type-level trees instead of value-level trees, in a similar fashion to how \ensuremath{\Conid{Index}} is an index in a type-level list instead of a value-level list:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{TTreePath}\;\Varid{p}\;\Varid{w}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Start}{}\<[11]%
\>[11]{}\mathbin{::}\Conid{TTreePath}\;\Varid{w}\;\Varid{w}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Left}{}\<[11]%
\>[11]{}\mathbin{::}\Conid{TTreePath}\;(\Varid{l}:\!\!+\!\!\!+\!\!:\Varid{r})\;\Varid{w}\to \Conid{TTreePath}\;\Varid{l}\;\Varid{w}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{Right}{}\<[11]%
\>[11]{}\mathbin{::}\Conid{TTreePath}\;(\Varid{l}:\!\!+\!\!\!+\!\!:\Varid{r})\;\Varid{w}\to \Conid{TTreePath}\;\Varid{r}\;\Varid{w}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We can now construct a \ensuremath{\Varid{testEquality}}-like function of the following type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{samePath}\mathbin{::}{}\<[14]%
\>[14]{}\Conid{TTreePath}\;\Varid{p}\;\Varid{w}\to \Conid{TTreePath}\;\Varid{p'}\;\Varid{w}{}\<[E]%
\\
\>[14]{}\to \Conid{Maybe}\;(\Varid{p}:\sim:\Varid{p'}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The implementation of this function is a bit more involved than for \ensuremath{\Conid{Index}}, but is unsurprising:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{41}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{samePath}\;\Conid{Start}\;{}\<[21]%
\>[21]{}\Conid{Start}{}\<[32]%
\>[32]{}\mathrel{=}\Conid{Just}\;\Conid{Refl}{}\<[E]%
\\
\>[B]{}\Varid{samePath}\;(\Conid{Left}\;\Varid{l})\;{}\<[21]%
\>[21]{}(\Conid{Left}\;\Varid{r}){}\<[32]%
\>[32]{}\mathrel{=}\Varid{weakL}{}\<[41]%
\>[41]{}\fmap\Varid{samePath}\;\Varid{l}\;\Varid{r}{}\<[E]%
\\
\>[B]{}\Varid{samePath}\;(\Conid{Right}\;\Varid{l})\;{}\<[21]%
\>[21]{}(\Conid{Right}\;\Varid{r}){}\<[32]%
\>[32]{}\mathrel{=}\Varid{weakR}{}\<[41]%
\>[41]{}\fmap\Varid{samePath}\;\Varid{l}\;\Varid{r}{}\<[E]%
\\
\>[B]{}\Varid{samePath}\;\anonymous \;{}\<[21]%
\>[21]{}\anonymous {}\<[32]%
\>[32]{}\mathrel{=}\Conid{Nothing}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{weakL}\mathbin{::}((\Varid{l}:\!\!+\!\!\!+\!\!:\Varid{r}):\sim:(\Varid{l'}:\!\!+\!\!\!+\!\!:\Varid{r'}))\to \Varid{l}:\sim:\Varid{l'}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{weakL}\;\Varid{x}\mathrel{=}\mathbf{case}\;\Varid{x}\;\mathbf{of}\;\Conid{Refl}\to \Conid{Refl}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{weakR}\mathbin{::}((\Varid{l}:\!\!+\!\!\!+\!\!:\Varid{r}):\sim:(\Varid{l'}:\!\!+\!\!\!+\!\!:\Varid{r'}))\to \Varid{r}:\sim:\Varid{r'}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{weakR}\;\Varid{x}\mathrel{=}\mathbf{case}\;\Varid{x}\;\mathbf{of}\;\Conid{Refl}\to \Conid{Refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We can use this function to implement a function that produces a proof that if two paths to a leaf are the same, then their associated types are the same:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{sameLeaf}\mathbin{::}{}\<[14]%
\>[14]{}\Conid{TTreePath}\;(\Conid{Single}\;\Varid{p})\;\Varid{w}\to {}\<[E]%
\\
\>[14]{}\Conid{TTreePath}\;(\Conid{Single}\;\Varid{p'})\;\Varid{w}\to {}\<[E]%
\\
\>[14]{}\Conid{Maybe}\;(\Varid{p}:\sim:\Varid{p'}){}\<[E]%
\\
\>[B]{}\Varid{sameLeaf}\;\Varid{l}\;\Varid{r}\mathrel{=}\Varid{weakenLeaf}\fmap\Varid{samePath}\;\Varid{l}\;\Varid{r}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{weakenLeaf}\mathbin{::}(\Conid{Single}\;\Varid{p}:\sim:\Conid{Single}\;\Varid{p'})\to \Varid{p}:\sim:\Varid{p'}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{weakenLeaf}\;\Varid{x}\mathrel{=}\mathbf{case}\;\Varid{x}\;\mathbf{of}\;\Conid{Refl}\to \Conid{Refl}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Now that we have encoded the invariant that when two key values are the same then their associated types must also the same, we can use this to implement a \emph{typed} name supply with the following interface:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{TNameSupply}\;\Varid{l}\;\Varid{s}\mathrel{=}\Conid{TTreePath}\;\Varid{l}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{TName}\;\Varid{s}\;\Varid{a}\mathrel{=}\Conid{TTreePath}\;(\Conid{Single}\;\Varid{a})\;\Varid{s}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{newTNameSupply}\mathbin{::}\Conid{TNameSupply}\;\Varid{s}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\Varid{tsplit}\mathbin{::}{}\<[12]%
\>[12]{}\Conid{TNameSupply}\;(\Varid{l}:\!\!+\!\!\!+\!\!:\Varid{r})\;\Varid{s}{}\<[E]%
\\
\>[12]{}\to (\Conid{TNameSupply}\;\Varid{l}\;\Varid{s},\Conid{TNameSupply}\;\Varid{r}\;\Varid{s}){}\<[E]%
\\
\>[B]{}\Varid{supplyTName}\mathbin{::}\Conid{TNameSupply}\;(\Conid{Single}\;\Varid{a})\;\Varid{s}\to \Conid{TName}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{sameName}\mathbin{::}{}\<[14]%
\>[14]{}\Conid{TName}\;\Varid{s}\;\Varid{a}\to \Conid{TName}\;\Varid{s}\;\Varid{b}\to {}\<[E]%
\\
\>[14]{}\Conid{Maybe}\;(\Varid{a}:\sim:\Varid{b}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
A typed name supply of type \ensuremath{\Conid{TNameSupply}\;\Varid{l}\;\Varid{s}} gives unique names for the types in the subtree \ensuremath{\Varid{l}} which can be tested for equality, using \ensuremath{\Varid{sameName}}, with all names which are created in the context \ensuremath{\Varid{s}}. The implementations of the name supply functions are completely analogous to their untyped counterparts.

By using the typed name supply instead of the regular name supply and altering the types in the interface to reflect this change, we obtain an implementation of what we call the \emph{indexed} Key monad, with the following interface:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{newKeyIM}{}\<[17]%
\>[17]{}\mathbin{::}{}\<[21]%
\>[21]{}\Conid{KeyIM}\;\Varid{s}\;(\Conid{Single}\;\Varid{a})\;(\Conid{Key}\;\Varid{s}\;\Varid{a}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{rreturn}{}\<[17]%
\>[17]{}\mathbin{::}{}\<[21]%
\>[21]{}\Varid{a}\to \Conid{KeyIM}\;\Conid{Empty}\;\Varid{s}\;\Varid{a}{}\<[E]%
\\
\>[B]{}(\cdot\!\!\!\bind){}\<[17]%
\>[17]{}\mathbin{::}{}\<[21]%
\>[21]{}\Conid{KeyIM}\;\Varid{s}\;\Varid{l}\;\Varid{a}\to (\Varid{a}\to \Conid{KeyIM}\;\Varid{s}\;\Varid{r}\;\Varid{b}){}\<[E]%
\\
\>[21]{}\hsindent{1}{}\<[22]%
\>[22]{}\to \Conid{KeyIm}\;\Varid{s}\;(\Varid{l}:\!\!+\!\!\!+\!\!:\Varid{r})\;\Varid{b}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{runKeyIM}{}\<[17]%
\>[17]{}\mathbin{::}(\forall\;\Varid{s}.\:\Conid{KeyIM}\;\Varid{s}\;\Varid{l}\;\Varid{a})\to \Varid{a}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{testEquality}{}\<[17]%
\>[17]{}\mathbin{::}{}\<[21]%
\>[21]{}\Conid{Key}\;\Varid{s}\;\Varid{a}\to \Conid{Key}\;\Varid{s}\;\Varid{b}\to \Conid{Maybe}\;(\Varid{a}:\sim:\Varid{b}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The implementation of this interface is completely analogous to the implementation of the Key monad in the previous subsection. The only difference is that \ensuremath{\Varid{testEquality}} now uses \ensuremath{\Varid{sameName}}, omitting the need for \ensuremath{\Varid{unsafeCoerce}}.
This interface is an instance of the \emph{parametric effect monad} type class\cite{peff}. 

Note that in the implementation of \ensuremath{\Varid{runKeyIm}} the universally quantified type variable \ensuremath{\Varid{s}} gets unified with \ensuremath{\Varid{l}} in order to use \ensuremath{\Varid{newTNameSupply}}. This ``closes the context'', stating that the context is precisely the types which are created in the computation. In contrast, in \ensuremath{\Varid{runKeyM}} the type variable was not given an interpretation.

While we have succeeded in avoiding \ensuremath{\Varid{unsafeCoerce}}, this construction is \emph{less powerful} than the regular Key monad because the types of the keys which are going to be created must now be \emph{statically known}. All example use cases of the Key monad in this paper rely on the fact that the type of the keys which are going to be created do not have to be statically known. For example, it is not possible to implement a translation from parametric \hoas{} to de Bruijn indices with \ensuremath{\Conid{KeyIM}}, because the type of the keys which would have to be created is precisely the information that a parametric \hoas{} representation lacks.

\subsection{Attempting to Recover the Key Monad}

Can we formalize the invariant through types and provide the regular Key monad interface? We believe not.

An obvious attempt at this is hiding the extra type of \ensuremath{\Conid{KeyIM}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{KeyM}\;\Varid{s}\;\Varid{a}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Conid{KeyM}\mathbin{::}\Conid{KeyIM}\;\Varid{s}\;\Varid{p}\;\Varid{a}\to \Conid{KeyM}\;\Varid{s}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
We denote this type by \ensuremath{\exists\;\Varid{p}.\:\Conid{KeyIM}\;\Varid{s}\;\Varid{p}\;\Varid{a}} for presentational purposes, although it is not valid Haskell. While this allows us to provide type-safe implementations of \ensuremath{\Varid{testEquality}}, \ensuremath{\Varid{fmap}}, \ensuremath{\Varid{newKey}} and \ensuremath{\Varid{return}}, things go awry for \ensuremath{\Varid{join}} (or \ensuremath{\bind }) and \ensuremath{\Varid{runKeyM}}.

Here is the problem that arises for \ensuremath{\Varid{runKeyM}}. We get the type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{runKeyM}\mathbin{::}(\forall\;\Varid{s}.\:\exists\;\Varid{p}.\:\Conid{KeyIM}\;\Varid{s}\;\Varid{p}\;\Varid{a})\to \Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
But to use \ensuremath{\Varid{runKeyIM}} the type should be:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{runKeyM}\mathbin{::}(\exists\;\Varid{p}.\:\forall\;\Varid{s}.\:\Conid{KeyIM}\;\Varid{s}\;\Varid{p}\;\Varid{a})\to \Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
These types are \emph{not} equivalent: the latter implies the former, but not the other way around. In the former, the type which is bound to \ensuremath{\Varid{p}} may depend on \ensuremath{\Varid{s}}, which cannot happen in the latter. 

Let us take a look at what happens if we allow this coercion and \ensuremath{\Varid{p}} does depend on \ensuremath{\Varid{s}}, for example when we create a key of type \ensuremath{\Conid{Key}\;\Varid{s}\;(\Conid{Key}\;\Varid{s}\;\Conid{Int})}. When the type \ensuremath{\Varid{s}} is now unified with the tree of types of the keys, it leads to a \emph{cyclic} type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{s}\:\sim\:(\Conid{Key}\;\Varid{s}\;\Conid{Int}):\!\!+\!\!\!+\!\!:\Varid{t}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
In the previous section, we demonstrated that allowing such keys, where the type of the key mentions \ensuremath{\Varid{s}}, allows us to write \ensuremath{\Varid{fix}} without recursion. In the worst case, allowing such cyclic types may lead to type unsoundness.

For \ensuremath{\Varid{join}} other problems arise. We need an implementation of type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{join}\mathbin{::}{}\<[10]%
\>[10]{}(\exists\;\Varid{p}.\:\Conid{KeyIM}\;\Varid{s}\;\Varid{p}\;(\exists\;\Varid{q}.\:\Conid{KeyIM}\;\Varid{s}\;\Varid{q}\;\Varid{a}))\to {}\<[E]%
\\
\>[10]{}\exists\;\Varid{r}.\:\Conid{KeyIM}\;\Varid{s}\;\Varid{r}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Expanding the definition of \ensuremath{\Conid{KeyIM}}, the type of the \emph{argument} we have is:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\exists\;\Varid{p}.\:\Conid{TNameSupply}\;\Varid{p}\;\Varid{s}\to \exists\;\Varid{q}.\:\Conid{TNameSupply}\;\Varid{q}\;\Varid{s}\to \Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
However, to use the implementation of \ensuremath{\Varid{join}} of \ensuremath{\Conid{KeyIM}}, we need the argument to be of type:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\exists\;\Varid{p}\;\Varid{q}.\:\Conid{TNameSupply}\;\Varid{p}\;\Varid{s}\to {}\<[33]%
\>[33]{}\Conid{TNameSupply}\;\Varid{q}\;\Varid{s}\to \Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Again, these two types are \emph{not} equivalent: the latter implies the former, but not the other way around. In general, \ensuremath{\Varid{q}} may depend on the value of \ensuremath{\Conid{TNameSupply}\;\Varid{p}\;\Varid{s}}. However, this is not the case in this implementation of \ensuremath{\Conid{KeyM}} because the name supply and \ensuremath{\Conid{Key}} types are abstract and hence cannot influences the choice of type \ensuremath{\Varid{q}}. Unfortunately, invariants like these are very hard to express in the type system. Also, when a computation creates a potentially infinite number of keys, will also lead to an \emph{infinite} type, which may again lead to type unsoundness.

\section{Discussion on the \st{} Monad Proof}
\label{stdis}

The \st{} monad was introduced in \cite{stmonad} and contained some safety statements and also a high-level description of a proof. The proof sketch mentions the use of parametricity, which is a doubtful proof technique to use because it is not established that parametricity still holds for a language with the \st{} monad. A follow-up paper \cite{LaunchburySabry} mentions another problem with the first paper, in particular that implementations of the lazy \st{} monad may actually generate the wrong result in a setting that is more eager. The follow-up paper claims to fix those issues with a new semantics and a proof sketch. However, a bug in this safety proof was discovered, which led to a series of papers \cite{LaunchburySabry,AriolaSabry} formalizing the treatment of different versions of encapsulating strict and lazy state threads in a functional language, culminating in \cite{MoggiSabry}. This final paper gives different formulations of strict and lazy state threads, one of them corresponding more or less to lazy state threads in Haskell (although not using global pointers). The aim of this final paper is to establish {\em type safety} of state threads. However, the paper only provides a proof sketch of type safety for one of the formulations, and only claims type safety (without a proof) for the other ones. With the exception of the original paper~\cite{stmonad}, all these papers consider only \emph{local state}, that is, each state thread has its own memory, in contrast to the actual implementation of the \st{} monad.

Even if type safety may now be considered to have been established by these papers, we are still left with referential transparency and abstraction safety. We are unaware of any work that establishes parametricity or referential transparency in the presence of the \st{} monad. Referential transparency is quite tricky for actual implementations of the \st{} monad since efficient implementations use global pointers. Abstraction safety is also very important because most people assume that parametricity in Haskell actually holds, without giving it a second thought that the \st{} monad may destroy it. 

Now, we actually believe that the \st{} monad (and also the Key monad) is safe in all of these senses. But we have also realized that {\em there exist no actual proofs of these statements in the published literature}. We think that the Key monad, which is arguably simpler than the \st{} monad, could be a first step on the way to proving the \st{} monad safe.

\section{Conclusions}

In the \st{} monad, one of the invariants that must hold is that when two references are the same, then their types must also be the same. We presented the Key monad, which splits reasoning based on this invariant into a separate interface, and makes it available to the user. We showed that this new interface gives a form of dynamic typing without the need for \ensuremath{\Conid{Typeable}} constraints, which allows us to do things we could not do before: it allows us to implement heterogeneous maps, to implement the \st{} monad, to implement an embedded form of arrow syntax and to translate parametric \hoas{} to typed de Bruijn indices. The Key monad is simpler than the \st{} monad, since the former embodies just one aspect of the latter. A full proof of the safety of the \st{} monad remains elusive to this day. We feel that the Key monad might be the key to the proof of the \st{} monad. 

\paragraph{Acknowledgements}
We thank Gershom Bazerman, Jonas Dure\-g{\aa}rd and John Hughes for helpful comments and insightful discussions. This work was supported in part by The Sloan Foundation.
\label{conc}
\bibliographystyle{apalike}
\bibliography{refs}

\end{document}
